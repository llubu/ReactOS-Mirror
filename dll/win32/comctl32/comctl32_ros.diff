diff -pudN e:\wine\dlls\comctl32/comctl32.h e:\reactos\dll\win32\comctl32/comctl32.h
--- e:\wine\dlls\comctl32/comctl32.h	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/comctl32.h	2014-03-05 11:47:40 +0100
@@ -53,67 +53,6 @@
 extern HMODULE COMCTL32_hModule DECLSPEC_HIDDEN;
 extern HBRUSH  COMCTL32_hPattern55AABrush DECLSPEC_HIDDEN;
 
-/* Property sheet / Wizard */
-#define IDD_PROPSHEET 1006
-#define IDD_WIZARD    1020
-
-#define IDC_TABCONTROL   12320
-#define IDC_APPLY_BUTTON 12321
-#define IDC_BACK_BUTTON  12323
-#define IDC_NEXT_BUTTON  12324
-#define IDC_FINISH_BUTTON 12325
-#define IDC_SUNKEN_LINE   12326
-#define IDC_SUNKEN_LINEHEADER 12327
-
-#define IDS_CLOSE	  4160
-
-/* Toolbar customization dialog */
-#define IDD_TBCUSTOMIZE     200
-
-#define IDC_AVAILBTN_LBOX   201
-#define IDC_RESET_BTN       202
-#define IDC_TOOLBARBTN_LBOX 203
-#define IDC_REMOVE_BTN      204
-#define IDC_HELP_BTN        205
-#define IDC_MOVEUP_BTN      206
-#define IDC_MOVEDN_BTN      207
-
-#define IDS_SEPARATOR      1024
-
-/* Toolbar imagelist bitmaps */
-#define IDB_STD_SMALL       120
-#define IDB_STD_LARGE       121
-#define IDB_VIEW_SMALL      124
-#define IDB_VIEW_LARGE      125
-#define IDB_HIST_SMALL      130
-#define IDB_HIST_LARGE      131
-
-#define IDM_TODAY                      4163
-#define IDM_GOTODAY                    4164
-
-/* Treeview Checkboxes */
-
-#define IDT_CHECK        401
-
-
-/* Cursors */
-#define IDC_MOVEBUTTON                  102
-#define IDC_COPY                        104
-#define IDC_DIVIDER                     106
-#define IDC_DIVIDEROPEN                 107
-
-
-/* DragList resources */
-#define IDI_DRAGARROW                   501
-
-/* HOTKEY internal strings */
-#define HKY_NONE                        2048
-
-/* Tooltip icons */
-#define IDI_TT_INFO_SM                   22
-#define IDI_TT_WARN_SM                   25
-#define IDI_TT_ERROR_SM                  28
-
 typedef struct
 {
     COLORREF clrBtnHighlight;       /* COLOR_BTNHIGHLIGHT                  */
@@ -149,8 +88,6 @@ INT  Str_GetPtrAtoW (LPCSTR lpSrc, LPWST
 BOOL Str_SetPtrAtoW (LPWSTR *lppDest, LPCSTR lpSrc) DECLSPEC_HIDDEN;
 BOOL Str_SetPtrWtoA (LPSTR *lppDest, LPCWSTR lpSrc) DECLSPEC_HIDDEN;
 
-#define COMCTL32_VERSION_MINOR 81
-
 /* Our internal stack structure of the window procedures to subclass */
 typedef struct _SUBCLASSPROCS {
     SUBCLASSPROC subproc;
diff -pudN e:\wine\dlls\comctl32/commctrl.c e:\reactos\dll\win32\comctl32/commctrl.c
--- e:\wine\dlls\comctl32/commctrl.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/commctrl.c	2016-03-01 20:00:53 +0100
@@ -60,6 +60,19 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(commctrl);
 
+#define NAME       L"microsoft.windows.common-controls"
+#define VERSION    L"6.0.2600.2982"
+#define PUBLIC_KEY L"6595b64144ccf1df"
+
+#ifdef __i386__
+#define ARCH L"x86"
+#elif defined __x86_64__
+#define ARCH L"amd64"
+#else
+#define ARCH L"none"
+#endif
+
+static const WCHAR manifest_filename[] = ARCH L"_" NAME L"_" PUBLIC_KEY L"_" VERSION L"_none_deadbeef.manifest";
 
 static LRESULT WINAPI COMCTL32_SubclassProc (HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
 
@@ -81,6 +94,67 @@ static const WCHAR strCC32SubclassInfo[]
     'C','C','3','2','S','u','b','c','l','a','s','s','I','n','f','o',0
 };
 
+static BOOL create_manifest(BOOL install)
+{
+    WCHAR *pwszBuf;
+    HRSRC hResInfo;
+    HGLOBAL hResData;
+    PVOID pManifest;
+    DWORD cchBuf, cbManifest, cbWritten;
+    HANDLE hFile;
+    BOOL bRet = FALSE;
+
+    hResInfo = FindResourceW(COMCTL32_hModule, L"WINE_MANIFEST", (LPWSTR)RT_MANIFEST);
+    if (!hResInfo)
+        return FALSE;
+
+    cbManifest = SizeofResource(COMCTL32_hModule, hResInfo);
+    if (!cbManifest)
+        return FALSE;
+
+    hResData = LoadResource(COMCTL32_hModule, hResInfo);
+    if (!hResData)
+        return FALSE;
+
+    pManifest = LockResource(hResData);
+    if (!pManifest)
+        return FALSE;
+
+    cchBuf = GetWindowsDirectoryW(NULL, 0) * sizeof(WCHAR) + sizeof(L"\\winsxs\\manifests\\") + sizeof(manifest_filename);
+    pwszBuf = (WCHAR*)HeapAlloc(GetProcessHeap(), 0, cchBuf * sizeof(WCHAR));
+    if (!pwszBuf)
+        return FALSE;
+
+    GetWindowsDirectoryW(pwszBuf, cchBuf);
+    lstrcatW(pwszBuf, L"\\winsxs");
+    CreateDirectoryW(pwszBuf, NULL);
+    lstrcatW(pwszBuf, L"\\manifests\\");
+    CreateDirectoryW(pwszBuf, NULL);
+    lstrcatW(pwszBuf, manifest_filename);
+    if (install)
+    {
+        hFile = CreateFileW(pwszBuf, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
+        if (hFile != INVALID_HANDLE_VALUE)
+        {
+            if (WriteFile(hFile, pManifest, cbManifest, &cbWritten, NULL) && cbWritten == cbManifest)
+                bRet = TRUE;
+
+            CloseHandle(hFile);
+
+            if (!bRet)
+                DeleteFileW(pwszBuf);
+            else
+                TRACE("created %s\n", debugstr_w(pwszBuf));
+        }
+    }
+    else
+        bRet = DeleteFileW(pwszBuf);
+
+    HeapFree(GetProcessHeap(), 0, pwszBuf);
+
+    return bRet;
+}
+
 
 /***********************************************************************
  * DllMain [Internal]
@@ -917,6 +991,12 @@ HRESULT WINAPI DllGetVersion (DLLVERSION
 HRESULT WINAPI DllInstall(BOOL bInstall, LPCWSTR cmdline)
 {
     TRACE("(%u, %s): stub\n", bInstall, debugstr_w(cmdline));
+    if (!create_manifest(bInstall))
+    {
+        ERR("create_manifest failed!\n");
+        return HRESULT_FROM_WIN32(GetLastError());
+    }
+
     return S_OK;
 }
 
@@ -1580,33 +1660,114 @@ LRESULT WINAPI SetPathWordBreakProc(HWND
  *
  * Draw text with shadow.
  */
-int WINAPI DrawShadowText(HDC hdc, LPCWSTR text, UINT length, RECT *rect, DWORD flags,
-                          COLORREF crText, COLORREF crShadow, int offset_x, int offset_y)
+int WINAPI DrawShadowText(HDC hdc, LPCWSTR pszText, UINT cch, RECT *prc, DWORD dwFlags,
+                          COLORREF crText, COLORREF crShadow, int ixOffset, int iyOffset)
 {
-    int bkmode, ret;
-    COLORREF clr;
-    RECT r;
+    COLORREF crOldText;
+    RECT rcText;
+    INT iRet, x, y, x2, y2;
+    BYTE *pBits;
+    HBITMAP hbm, hbmOld;
+    BITMAPINFO bi;
+    HDC hdcMem;
+    HFONT hOldFont;
+    BLENDFUNCTION bf;
 
-    FIXME("(%p, %s, %d, %p, 0x%08x, 0x%08x, 0x%08x, %d, %d): semi-stub\n", hdc, debugstr_w(text),
-        length, rect, flags, crText, crShadow, offset_x, offset_y);
+    /* Create 32 bit DIB section for the shadow */
+    ZeroMemory(&bi, sizeof(bi));
+    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
+    bi.bmiHeader.biWidth = prc->right - prc->left + 4;
+    bi.bmiHeader.biHeight = prc->bottom - prc->top + 5; // bottom-up DIB
+    bi.bmiHeader.biPlanes = 1;
+    bi.bmiHeader.biBitCount = 32;
+    bi.bmiHeader.biCompression = BI_RGB;
+    hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (PVOID*)&pBits, NULL, 0);
+    if(!hbm)
+    {
+        ERR("CreateDIBSection failed\n");
+        return 0;
+    }
 
-    bkmode = SetBkMode(hdc, TRANSPARENT);
-    clr = SetTextColor(hdc, crShadow);
+    /* Create memory device context for new DIB section and select it */
+    hdcMem = CreateCompatibleDC(hdc);
+    if(!hdcMem)
+    {
+        ERR("CreateCompatibleDC failed\n");
+        DeleteObject(hbm);
+        return 0;
+    }
 
-    /* FIXME: for shadow we need to render normally, blur it, and blend with current background. */
-    r = *rect;
-    OffsetRect(&r, 1, 1);
-    DrawTextW(hdc, text, length, &r, flags);
+    hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
 
-    SetTextColor(hdc, crText);
+    /* Draw text on our helper bitmap */
+    hOldFont = (HFONT)SelectObject(hdcMem, GetCurrentObject(hdc, OBJ_FONT));
+    SetTextColor(hdcMem, RGB(16, 16, 16));
+    SetBkColor(hdcMem, RGB(0, 0, 0));
+    SetBkMode(hdcMem, TRANSPARENT);
+    SetRect(&rcText, 0, 0, prc->right - prc->left, prc->bottom - prc->top);
+    DrawTextW(hdcMem, pszText, cch, &rcText, dwFlags);
+    SelectObject(hdcMem, hOldFont);
 
-    /* with text color on top of a shadow */
-    ret = DrawTextW(hdc, text, length, rect, flags);
+    /* Flush GDI so data pointed by pBits is valid */
+    GdiFlush();
 
-    SetTextColor(hdc, clr);
-    SetBkMode(hdc, bkmode);
+    /* Set alpha of pixels (forget about colors for now. They will be changed in next loop).
+       We copy text image 4*5 times and each time alpha is added */
+    for (x = 0; x < bi.bmiHeader.biWidth; ++x)
+        for (y = 0; y < bi.bmiHeader.biHeight; ++y)
+        {
+            BYTE *pDest = &pBits[(y * bi.bmiHeader.biWidth + x) * 4];
+            UINT Alpha = 0;
 
-    return ret;
+            for (x2 = x - 4 + 1; x2 <= x; ++x2)
+                for (y2 = y; y2 < y + 5; ++y2)
+                {
+                    if (x2 >= 0 && x2 < bi.bmiHeader.biWidth && y2 >= 0 && y2 < bi.bmiHeader.biHeight)
+                    {
+                        BYTE *pSrc = &pBits[(y2 * bi.bmiHeader.biWidth + x2) * 4];
+                        Alpha += pSrc[0];
+                    }
+                }
+
+            if (Alpha > 255)
+                Alpha = 255;
+            pDest[3] = Alpha;
+        }
+
+    /* Now set the color of each pixel to shadow color * alpha (see GdiAlphaBlend) */
+    for (x = 0; x < bi.bmiHeader.biWidth; ++x)
+        for (y = 0; y < bi.bmiHeader.biHeight; ++y)
+        {
+            BYTE *pDest = &pBits[(y * bi.bmiHeader.biWidth + x) * 4];
+            pDest[0] = GetBValue(crShadow) * pDest[3] / 255;
+            pDest[1] = GetGValue(crShadow) * pDest[3] / 255;
+            pDest[2] = GetRValue(crShadow) * pDest[3] / 255;
+        }
+
+    /* Fix ixOffset of the shadow (tested on Win) */
+    ixOffset -= 3;
+    iyOffset -= 3;
+
+    /* Alpha blend helper image to destination DC */
+    bf.BlendOp = AC_SRC_OVER;
+    bf.BlendFlags = 0;
+    bf.SourceConstantAlpha = 255;
+    bf.AlphaFormat = AC_SRC_ALPHA;
+    if (!GdiAlphaBlend(hdc, prc->left + ixOffset, prc->top + iyOffset, bi.bmiHeader.biWidth, bi.bmiHeader.biHeight, hdcMem, 0, 0, bi.bmiHeader.biWidth, bi.bmiHeader.biHeight, bf))
+        ERR("GdiAlphaBlend failed: %lu\n", GetLastError());
+
+    /* Delete the helper bitmap */
+    SelectObject(hdcMem, hbmOld);
+    DeleteObject(hbm);
+    DeleteDC(hdcMem);
+
+    /* Finally draw the text over shadow */
+    crOldText = SetTextColor(hdc, crText);
+    SetBkMode(hdc, TRANSPARENT);
+    iRet = DrawTextW(hdc, pszText, cch, prc, dwFlags);
+    SetTextColor(hdc, crOldText);
+
+    return iRet;
 }
 
 /***********************************************************************
@@ -1695,3 +1856,15 @@ HRESULT WINAPI LoadIconMetric(HINSTANCE 
 
     return LoadIconWithScaleDown(hinst, name, cx, cy, icon);
 }
+
+/***********************************************************************
+ * RegisterClassNameW [COMCTL32.@]
+ *
+ * Register window class again while using as SxS module.
+ */
+BOOLEAN WINAPI RegisterClassNameW(LPCWSTR className)
+{
+    /* FIXME: actually register redirected user32 class,
+              comctl32 classes are registered by this module anyway */
+    return TRUE;
+}
diff -pudN e:\wine\dlls\comctl32/imagelist.c e:\reactos\dll\win32\comctl32/imagelist.c
--- e:\wine\dlls\comctl32/imagelist.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/imagelist.c	2016-06-05 19:39:00 +0100
@@ -33,7 +33,7 @@
  *
  *  TODO:
  *    - Add support for ILD_PRESERVEALPHA, ILD_SCALE, ILD_DPISCALE
- *    - Add support for ILS_GLOW, ILS_SHADOW, ILS_SATURATE
+ *    - Add support for ILS_GLOW, ILS_SHADOW
  *    - Thread-safe locking
  */
 
@@ -1229,8 +1229,11 @@ ImageList_DrawEx (HIMAGELIST himl, INT i
     return ImageList_DrawIndirect (&imldp);
 }
 
-
+#ifdef __REACTOS__
+static BOOL alpha_blend_image( HIMAGELIST himl, HDC srce_dc, HDC dest_dc, int dest_x, int dest_y,
+#else
 static BOOL alpha_blend_image( HIMAGELIST himl, HDC dest_dc, int dest_x, int dest_y,
+#endif
                                int src_x, int src_y, int cx, int cy, BLENDFUNCTION func,
                                UINT style, COLORREF blend_col )
 {
@@ -1255,9 +1258,17 @@ static BOOL alpha_blend_image( HIMAGELIS
     info->bmiHeader.biYPelsPerMeter = 0;
     info->bmiHeader.biClrUsed = 0;
     info->bmiHeader.biClrImportant = 0;
+#ifdef __REACTOS__
+    if (!(bmp = CreateDIBSection( srce_dc, info, DIB_RGB_COLORS, &bits, 0, 0 ))) goto done;
+#else
     if (!(bmp = CreateDIBSection( himl->hdcImage, info, DIB_RGB_COLORS, &bits, 0, 0 ))) goto done;
+#endif
     SelectObject( hdc, bmp );
+#ifdef __REACTOS__
+    BitBlt( hdc, 0, 0, cx, cy, srce_dc, src_x, src_y, SRCCOPY );
+#else
     BitBlt( hdc, 0, 0, cx, cy, himl->hdcImage, src_x, src_y, SRCCOPY );
+#endif
 
     if (blend_col != CLR_NONE)
     {
@@ -1330,6 +1341,68 @@ done:
     return ret;
 }
 
+#ifdef __REACTOS__
+HDC saturate_image( HIMAGELIST himl, HDC dest_dc, int dest_x, int dest_y,
+                    int src_x, int src_y, int cx, int cy, COLORREF rgbFg)
+{
+    HDC hdc = NULL;
+    HBITMAP bmp = 0;
+    BITMAPINFO *info;
+
+    unsigned int *ptr;
+    void *bits;
+    int i;
+
+    /* create a dc and its device independent bitmap for doing the work,
+       shamelessly copied from the alpha-blending function above */
+    if (!(hdc = CreateCompatibleDC( 0 ))) return FALSE;
+    if (!(info = HeapAlloc( GetProcessHeap(), 0, FIELD_OFFSET( BITMAPINFO, bmiColors[256] )))) goto done;
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = cx;
+    info->bmiHeader.biHeight = cy;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = cx * cy * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+    if (!(bmp = CreateDIBSection(himl->hdcImage, info, DIB_RGB_COLORS, &bits, 0, 0 ))) goto done;
+
+    /* bind both surfaces */
+    SelectObject(hdc, bmp);
+
+    /* copy into our dc the section that covers just the icon we we're asked for */
+    BitBlt(hdc, 0, 0, cx, cy, himl->hdcImage, src_x, src_y, SRCCOPY);
+
+    /* loop every pixel of the bitmap */
+    for (i = 0, ptr = bits; i < cx * cy; i++, ptr++)
+    {
+        COLORREF orig_color = *ptr;
+
+        /* calculate the effective luminance using the constants from here, adapted to the human eye:
+           <http://bobpowell.net/grayscale.aspx> */
+        float mixed_color = (GetRValue(orig_color) * .30 +
+                             GetGValue(orig_color) * .59 +
+                             GetBValue(orig_color) * .11);
+
+        *ptr = RGBA(mixed_color, mixed_color, mixed_color, GetAValue(orig_color));
+    }
+
+done:
+
+    if (bmp)
+        DeleteObject(bmp);
+
+    if (info)
+        HeapFree(GetProcessHeap(), 0, info);
+
+    /* return the handle to our desaturated dc, that will substitute its original counterpart in the next calls */
+    return hdc;
+}
+#endif /* __REACTOS__ */
+
 /*************************************************************************
  * ImageList_DrawIndirect [COMCTL32.@]
  *
@@ -1406,6 +1479,23 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
     oldImageFg = SetTextColor( hImageDC, RGB( 0, 0, 0 ) );
     oldImageBk = SetBkColor( hImageDC, RGB( 0xff, 0xff, 0xff ) );
 
+#ifdef __REACTOS__
+    /*
+     * If the ILS_SATURATE bit is enabled we should multiply the
+     * RGB colors of the original image by the contents of rgbFg.
+     */
+    if (fState & ILS_SATURATE)
+    {
+        hImageListDC = saturate_image(himl, pimldp->hdcDst, pimldp->x, pimldp->y,
+                                      pt.x, pt.y, cx, cy, pimldp->rgbFg);
+
+        /* shitty way of getting subroutines to blit at the right place (top left corner),
+           as our modified imagelist only contains a single image for performance reasons */
+        pt.x = 0;
+        pt.y = 0;
+    }
+#endif
+
     has_alpha = (himl->has_alpha && himl->has_alpha[pimldp->i]);
     if (!bMask && (has_alpha || (fState & ILS_ALPHA)))
     {
@@ -1426,7 +1516,11 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
 
         if (bIsTransparent)
         {
+#ifdef __REACTOS__
+            bResult = alpha_blend_image( himl, hImageListDC, pimldp->hdcDst, pimldp->x, pimldp->y,
+#else
             bResult = alpha_blend_image( himl, pimldp->hdcDst, pimldp->x, pimldp->y,
+#endif
                                          pt.x, pt.y, cx, cy, func, fStyle, blend_col );
             goto end;
         }
@@ -1436,7 +1530,11 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
 
         hOldBrush = SelectObject (hImageDC, CreateSolidBrush (colour));
         PatBlt( hImageDC, 0, 0, cx, cy, PATCOPY );
+#ifdef __REACTOS__
+        alpha_blend_image( himl, hImageListDC, hImageDC, 0, 0, pt.x, pt.y, cx, cy, func, fStyle, blend_col );
+#else
         alpha_blend_image( himl, hImageDC, 0, 0, pt.x, pt.y, cx, cy, func, fStyle, blend_col );
+#endif
         DeleteObject (SelectObject (hImageDC, hOldBrush));
         bResult = BitBlt( pimldp->hdcDst, pimldp->x,  pimldp->y, cx, cy, hImageDC, 0, 0, SRCCOPY );
         goto end;
@@ -1530,7 +1628,9 @@ ImageList_DrawIndirect (IMAGELISTDRAWPAR
 	}
     }
 
+#ifndef __REACTOS__
     if (fState & ILS_SATURATE) FIXME("ILS_SATURATE: unimplemented!\n");
+#endif
     if (fState & ILS_GLOW) FIXME("ILS_GLOW: unimplemented!\n");
     if (fState & ILS_SHADOW) FIXME("ILS_SHADOW: unimplemented!\n");
 
Common subdirectories: e:\wine\dlls\comctl32/lang and e:\reactos\dll\win32\comctl32/lang
diff -pudN e:\wine\dlls\comctl32/listview.c e:\reactos\dll\win32\comctl32/listview.c
--- e:\wine\dlls\comctl32/listview.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/listview.c	2016-06-05 19:39:00 +0100
@@ -287,6 +287,9 @@ typedef struct tagLISTVIEW_INFO
   COLORREF clrBk;
   COLORREF clrText;
   COLORREF clrTextBk;
+#ifdef __REACTOS__
+  BOOL bDefaultBkColor;
+#endif
 
   /* font */
   HFONT hDefaultFont;
@@ -1678,8 +1681,24 @@ static inline BOOL LISTVIEW_GetItemW(con
 /* used to handle collapse main item column case */
 static inline BOOL LISTVIEW_DrawFocusRect(const LISTVIEW_INFO *infoPtr, HDC hdc)
 {
+#ifdef __REACTOS__
+    BOOL Ret = FALSE;
+
+    if (infoPtr->rcFocus.left < infoPtr->rcFocus.right)
+    {
+        DWORD dwOldBkColor, dwOldTextColor;
+
+        dwOldBkColor = SetBkColor(hdc, RGB(255, 255, 255));
+        dwOldTextColor = SetBkColor(hdc, RGB(0, 0, 0));
+        Ret = DrawFocusRect(hdc, &infoPtr->rcFocus);
+        SetBkColor(hdc, dwOldBkColor);
+        SetBkColor(hdc, dwOldTextColor);
+    }
+    return Ret;
+#else
     return (infoPtr->rcFocus.left < infoPtr->rcFocus.right) ?
             DrawFocusRect(hdc, &infoPtr->rcFocus) : FALSE;
+#endif
 }
 
 /* Listview invalidation functions: use _only_ these functions to invalidate */
@@ -4671,7 +4690,12 @@ static void LISTVIEW_DrawItemPart(LISTVI
     if (infoPtr->uView == LV_VIEW_DETAILS && infoPtr->dwLvExStyle & LVS_EX_GRIDLINES)
         rcLabel.bottom--;
 
-    DrawTextW(nmlvcd->nmcd.hdc, item->pszText, -1, &rcLabel, format);
+#ifdef __REACTOS__
+    if ((!(item->state & LVIS_SELECTED) || !infoPtr->bFocus) && (infoPtr->dwLvExStyle & LVS_EX_TRANSPARENTSHADOWTEXT))
+        DrawShadowText(nmlvcd->nmcd.hdc, item->pszText, -1, &rcLabel, format, RGB(255, 255, 255), RGB(0, 0, 0), 2, 2);
+    else
+#endif
+        DrawTextW(nmlvcd->nmcd.hdc, item->pszText, -1, &rcLabel, format);
 }
 
 /***
@@ -5212,7 +5236,11 @@ enddraw:
 
     /* Draw marquee rectangle if appropriate */
     if (infoPtr->bMarqueeSelect)
+    {
+        SetBkColor(hdc, RGB(255, 255, 255));
+        SetTextColor(hdc, RGB(0, 0, 0));
         DrawFocusRect(hdc, &infoPtr->marqueeDrawRect);
+    }
 
     if (cdmode & CDRF_NOTIFYPOSTPAINT)
 	notify_postpaint(infoPtr, &nmlvcd);
@@ -8013,6 +8041,9 @@ static BOOL LISTVIEW_SetBkColor(LISTVIEW
 {
     TRACE("(color=%x)\n", color);
 
+#ifdef __REACTOS__
+    infoPtr->bDefaultBkColor = FALSE;
+#endif
     if(infoPtr->clrBk != color) {
 	if (infoPtr->clrBk != CLR_NONE) DeleteObject(infoPtr->hBkBrush);
 	infoPtr->clrBk = color;
@@ -8688,7 +8719,7 @@ static DWORD LISTVIEW_SetIconSpacing(LIS
     return oldspacing;
 }
 
-static inline void set_icon_size(SIZE *size, HIMAGELIST himl, BOOL small)
+static inline void set_icon_size(SIZE *size, HIMAGELIST himl, BOOL is_small)
 {
     INT cx, cy;
     
@@ -8699,8 +8730,8 @@ static inline void set_icon_size(SIZE *s
     }
     else
     {
-	size->cx = GetSystemMetrics(small ? SM_CXSMICON : SM_CXICON);
-	size->cy = GetSystemMetrics(small ? SM_CYSMICON : SM_CYICON);
+	size->cx = GetSystemMetrics(is_small ? SM_CXSMICON : SM_CXICON);
+	size->cy = GetSystemMetrics(is_small ? SM_CYSMICON : SM_CYICON);
     }
 }
 
@@ -9435,6 +9466,9 @@ static LRESULT LISTVIEW_NCCreate(HWND hw
   infoPtr->clrText = CLR_DEFAULT;
   infoPtr->clrTextBk = CLR_DEFAULT;
   LISTVIEW_SetBkColor(infoPtr, comctl32_color.clrWindow);
+#ifdef __REACTOS__
+  infoPtr->bDefaultBkColor = TRUE;
+#endif
 
   /* set default values */
   infoPtr->nFocusedItem = -1;
@@ -11718,6 +11752,14 @@ LISTVIEW_WindowProc(HWND hwnd, UINT uMsg
 
   case WM_SYSCOLORCHANGE:
     COMCTL32_RefreshSysColors();
+#ifdef __REACTOS__
+    if (infoPtr->bDefaultBkColor)
+    {
+        LISTVIEW_SetBkColor(infoPtr, comctl32_color.clrWindow);
+        infoPtr->bDefaultBkColor = TRUE;
+        LISTVIEW_InvalidateList(infoPtr);
+    }
+#endif
     return 0;
 
 /*	case WM_TIMER: */
diff -pudN e:\wine\dlls\comctl32/propsheet.c e:\reactos\dll\win32\comctl32/propsheet.c
--- e:\wine\dlls\comctl32/propsheet.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/propsheet.c	2016-06-05 19:39:01 +0100
@@ -2355,12 +2355,19 @@ static void PROPSHEET_SetWizButtons(HWND
   HWND hwndFinish = GetDlgItem(hwndDlg, IDC_FINISH_BUTTON);
   BOOL enable_finish = ((dwFlags & PSWIZB_FINISH) || psInfo->hasFinish) && !(dwFlags & PSWIZB_DISABLEDFINISH);
 
+#ifdef __REACTOS__
+  HWND hwndCancel = GetDlgItem(hwndDlg, IDCANCEL);
+  INT iDefItem = 0;
+  HWND hwndFocus;
+#endif
+
   TRACE("%d\n", dwFlags);
 
   EnableWindow(hwndBack, dwFlags & PSWIZB_BACK);
   EnableWindow(hwndNext, dwFlags & PSWIZB_NEXT);
   EnableWindow(hwndFinish, enable_finish);
 
+#ifndef __REACTOS__
   /* set the default pushbutton to an enabled button */
   if (enable_finish)
     SendMessageW(hwndDlg, DM_SETDEFID, IDC_FINISH_BUTTON, 0);
@@ -2370,6 +2377,7 @@ static void PROPSHEET_SetWizButtons(HWND
     SendMessageW(hwndDlg, DM_SETDEFID, IDC_BACK_BUTTON, 0);
   else
     SendMessageW(hwndDlg, DM_SETDEFID, IDCANCEL, 0);
+#endif
 
   if (!psInfo->hasFinish)
   {
@@ -2389,6 +2397,25 @@ static void PROPSHEET_SetWizButtons(HWND
       ShowWindow(hwndNext, SW_SHOW);
     }
   }
+
+#ifdef __REACTOS__
+  /* set the default pushbutton to an enabled button */
+  if (((dwFlags & PSWIZB_FINISH) || psInfo->hasFinish) && !(dwFlags & PSWIZB_DISABLEDFINISH))
+    iDefItem = IDC_FINISH_BUTTON;
+  else if (dwFlags & PSWIZB_NEXT)
+    iDefItem = IDC_NEXT_BUTTON;
+  else if (dwFlags & PSWIZB_BACK)
+    iDefItem = IDC_BACK_BUTTON;
+  else
+    iDefItem = IDCANCEL;
+  SendMessageW(hwndDlg, DM_SETDEFID, iDefItem, 0);
+
+  /* Set focus if no control has it */
+  hwndFocus = GetFocus();
+  if (!hwndFocus || hwndFocus == hwndCancel)
+    SetFocus(GetDlgItem(hwndDlg, iDefItem));
+#endif
+
 }
 
 /******************************************************************************
diff -pudN e:\wine\dlls\comctl32/rebar.c e:\reactos\dll\win32\comctl32/rebar.c
--- e:\wine\dlls\comctl32/rebar.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/rebar.c	2016-06-05 19:39:01 +0100
@@ -50,7 +50,6 @@
  *   - WM_QUERYNEWPALETTE
  *   - WM_RBUTTONDOWN
  *   - WM_RBUTTONUP
- *   - WM_SYSCOLORCHANGE
  *   - WM_VKEYTOITEM
  *   - WM_WININICHANGE
  *   Notifications:
@@ -1821,16 +1820,43 @@ static LRESULT REBAR_EraseBkGnd (const R
     RECT cr;
     COLORREF old = CLR_NONE, new;
     HTHEME theme = GetWindowTheme (infoPtr->hwndSelf);
+#ifdef __REACTOS__
+    HRGN hrgn;
+#endif
 
     GetClientRect (infoPtr->hwndSelf, &cr);
 
+#ifdef __REACTOS__
+
+    if (theme)
+    {
+        if (IsThemeBackgroundPartiallyTransparent(theme, RP_BACKGROUND, 0))
+        {
+            DrawThemeParentBackground (infoPtr->hwndSelf, hdc, &cr);
+        }
+        DrawThemeBackground (theme, hdc, 0, 0, &cr, NULL);
+    }
+
+    hrgn = CreateRectRgn(cr.left, cr.top, cr.right, cr.bottom);
+
+#endif
+
     oldrow = -1;
     for(i=0; i<infoPtr->uNumBands; i++) {
         RECT rcBand;
+#ifdef __REACTOS__
+        RECT rcBandReal;
+        HRGN hrgnBand;
+#endif
+
         lpBand = REBAR_GetBand(infoPtr, i);
 	if (HIDDENBAND(lpBand)) continue;
         translate_rect(infoPtr, &rcBand, &lpBand->rcBand);
 
+#ifdef __REACTOS__
+        rcBandReal = rcBand;
+#endif
+
 	/* draw band separator between rows */
 	if (lpBand->iRow != oldrow) {
 	    oldrow = lpBand->iRow;
@@ -1855,6 +1881,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 		}
                 TRACE ("drawing band separator bottom (%s)\n",
                        wine_dbgstr_rect(&rcRowSep));
+#ifdef __REACTOS__
+        rcBandReal = rcRowSep;
+#endif
 	    }
 	}
 
@@ -1865,6 +1894,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 	    if (infoPtr->dwStyle & CCS_VERT) {
                 rcSep.bottom = rcSep.top;
 		rcSep.top -= SEP_WIDTH_SIZE;
+#ifdef __REACTOS__
+        rcBandReal.top -= SEP_WIDTH_SIZE;
+#endif
                 if (theme)
                     DrawThemeEdge (theme, hdc, RP_BAND, 0, &rcSep, EDGE_ETCHED, BF_BOTTOM, NULL);
                 else
@@ -1873,6 +1905,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 	    else {
                 rcSep.right = rcSep.left;
 		rcSep.left -= SEP_WIDTH_SIZE;
+#ifdef __REACTOS__
+        rcBandReal.left -= SEP_WIDTH_SIZE;
+#endif
                 if (theme)
                     DrawThemeEdge (theme, hdc, RP_BAND, 0, &rcSep, EDGE_ETCHED, BF_RIGHT, NULL);
                 else
@@ -1903,6 +1938,9 @@ static LRESULT REBAR_EraseBkGnd (const R
 #endif
 	}
 
+#ifdef __REACTOS__
+        if (!theme)
+#else
         if (theme)
         {
             /* When themed, the background color is ignored (but not a
@@ -1910,6 +1948,7 @@ static LRESULT REBAR_EraseBkGnd (const R
             DrawThemeBackground (theme, hdc, 0, 0, &cr, &rcBand);
         }
         else
+#endif
         {
             old = SetBkColor (hdc, new);
             TRACE("%s background color=0x%06x, band %s\n",
@@ -1920,7 +1959,26 @@ static LRESULT REBAR_EraseBkGnd (const R
             if (lpBand->clrBack != CLR_NONE)
                 SetBkColor (hdc, old);
         }
+
+#ifdef __REACTOS__
+        hrgnBand = CreateRectRgn(rcBandReal.left, rcBandReal.top, rcBandReal.right, rcBandReal.bottom);
+        CombineRgn(hrgn, hrgn, hrgnBand, RGN_DIFF);
+        DeleteObject(hrgnBand);
+#endif
+    }
+
+#if 1
+#ifdef __REACTOS__
+    if (!theme)
+#endif
+    {
+        //FIXME: Apparently painting the remaining area is a v6 feature
+        HBRUSH hbrush = CreateSolidBrush(new);
+        FillRgn(hdc, hrgn, hbrush);
+        DeleteObject(hbrush);
+        DeleteObject(hrgn);
     }
+#endif
     return TRUE;
 }
 
@@ -2889,12 +2947,26 @@ REBAR_ShowBand (REBAR_INFO *infoPtr, INT
 
 
 static LRESULT
+#ifdef __REACTOS__
+REBAR_SizeToRect (REBAR_INFO *infoPtr, WPARAM flags, RECT *lpRect)
+#else
 REBAR_SizeToRect (REBAR_INFO *infoPtr, const RECT *lpRect)
+#endif
 {
     if (!lpRect) return FALSE;
 
     TRACE("[%s]\n", wine_dbgstr_rect(lpRect));
     REBAR_SizeToHeight(infoPtr, get_rect_cy(infoPtr, lpRect));
+
+#ifdef __REACTOS__
+    /* Note that this undocumented flag is available on comctl32 v6 or later */
+    if ((flags & RBSTR_CHANGERECT) != 0)
+    {
+        RECT rcRebar;
+        GetClientRect(infoPtr->hwndSelf, &rcRebar);
+        lpRect->bottom = lpRect->top + (rcRebar.bottom - rcRebar.top);
+    }
+#endif
     return TRUE;
 }
 
@@ -3201,7 +3273,11 @@ REBAR_NCCalcSize (const REBAR_INFO *info
     else if ((theme = GetWindowTheme (infoPtr->hwndSelf)))
     {
         /* FIXME: should use GetThemeInt */
+#ifdef __REACTOS__
+        rect->top = (rect->top + 1 < rect->bottom) ? rect->top : rect->bottom;
+#else
         rect->top = min(rect->top + 1, rect->bottom);
+#endif
     }
     TRACE("new client=(%s)\n", wine_dbgstr_rect(rect));
     return 0;
@@ -3652,7 +3728,11 @@ REBAR_WindowProc (HWND hwnd, UINT uMsg, 
 	    return REBAR_ShowBand (infoPtr, wParam, lParam);
 
 	case RB_SIZETORECT:
+#ifdef __REACTOS__
+	    return REBAR_SizeToRect (infoPtr, wParam, (LPRECT)lParam);
+#else
 	    return REBAR_SizeToRect (infoPtr, (LPCRECT)lParam);
+#endif
 
 
 /*    Messages passed to parent */
@@ -3735,6 +3815,11 @@ REBAR_WindowProc (HWND hwnd, UINT uMsg, 
 
         case WM_SYSCOLORCHANGE:
             COMCTL32_RefreshSysColors();
+#ifdef __REACTOS__
+            /* r51522 - Properly support WM_SYSCOLORCHANGE */
+            infoPtr->clrBtnText = comctl32_color.clrBtnText;
+            infoPtr->clrBtnFace = comctl32_color.clrBtnFace;
+#endif
             return 0;
 
 /*      case WM_VKEYTOITEM:     supported according to ControlSpy */
diff -pudN e:\wine\dlls\comctl32/toolbar.c e:\reactos\dll\win32\comctl32/toolbar.c
--- e:\wine\dlls\comctl32/toolbar.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/toolbar.c	2016-06-05 19:39:01 +0100
@@ -33,11 +33,9 @@
  *     - TBSTYLE_REGISTERDROP
  *     - TBSTYLE_EX_DOUBLEBUFFER
  *   - Messages:
- *     - TB_GETMETRICS
  *     - TB_GETOBJECT
  *     - TB_INSERTMARKHITTEST
  *     - TB_SAVERESTORE
- *     - TB_SETMETRICS
  *     - WM_WININICHANGE
  *   - Notifications:
  *     - NM_CHAR
@@ -125,6 +123,10 @@ typedef struct
     INT      nOldHit;
     INT      nHotItem;        /* index of the "hot" item */
     SIZE     szPadding;       /* padding values around button */
+#ifdef __REACTOS__
+    SIZE     szBarPadding;       /* padding values around the toolbar (NOT USED BUT STORED) */
+    SIZE     szSpacing;       /* spacing values between buttons */
+#endif
     INT      iTopMargin;      /* the top margin */
     INT      iListGap;        /* default gap between text and image for toolbar with list style */
     HFONT    hDefaultFont;
@@ -190,12 +192,24 @@ typedef enum
 #define ARROW_HEIGHT       3
 #define INSERTMARK_WIDTH   2
 
+/* default padding inside a button */
 #define DEFPAD_CX 7
 #define DEFPAD_CY 6
+
+#ifdef __REACTOS__
+/* default space between buttons and between rows */
+#define DEFSPACE_CX 7
+#define DEFSPACE_CY 6
+#endif
+
 #define DEFLISTGAP 4
 
 /* vertical padding used in list mode when image is present */
+#ifdef __REACTOS__
+#define LISTPAD_CY 2
+#else
 #define LISTPAD_CY 9
+#endif
 
 /* how wide to treat the bitmap if it isn't present */
 #define NONLIST_NOTEXT_OFFSET 2
@@ -239,7 +253,12 @@ static LRESULT TOOLBAR_SetButtonInfo(TOO
 
 static inline int default_top_margin(const TOOLBAR_INFO *infoPtr)
 {
+#ifndef __REACTOS__
     return (infoPtr->dwStyle & TBSTYLE_FLAT ? 0 : TOP_BORDER);
+#else /* r65766 */
+    /* This is the behaviour in comctl32 v6 */
+    return 0;
+#endif
 }
 
 static inline BOOL TOOLBAR_HasDropDownArrows(DWORD exStyle)
@@ -723,10 +742,14 @@ TOOLBAR_DrawImage(const TOOLBAR_INFO *in
                   const NMTBCUSTOMDRAW *tbcd, DWORD dwItemCDFlag)
 {
     HIMAGELIST himl = NULL;
-    BOOL draw_masked = FALSE;
+    BOOL draw_masked = FALSE, draw_desaturated = FALSE;
     INT index;
     INT offset = 0;
     UINT draw_flags = ILD_TRANSPARENT;
+#ifdef __REACTOS__
+    IMAGEINFO info = {0};
+    BITMAP bm = {0};
+#endif
 
     if (tbcd->nmcd.uItemState & (CDIS_DISABLED | CDIS_INDETERMINATE))
     {
@@ -734,7 +757,22 @@ TOOLBAR_DrawImage(const TOOLBAR_INFO *in
         if (!himl)
         {
             himl = TOOLBAR_GetImageListForDrawing(infoPtr, btnPtr, IMAGE_LIST_DEFAULT, &index);
+
+#ifdef __REACTOS__
+            ImageList_GetImageInfo(himl, index, &info);
+            GetObjectW(info.hbmImage, sizeof(bm), &bm);
+
+            if (bm.bmBitsPixel == 32)
+            {
+                draw_desaturated = TRUE;
+            }
+            else
+            {
+                draw_masked = TRUE;
+            }
+#else
             draw_masked = TRUE;
+#endif
         }
     }
     else if (tbcd->nmcd.uItemState & CDIS_CHECKED ||
@@ -765,9 +803,34 @@ TOOLBAR_DrawImage(const TOOLBAR_INFO *in
       index, himl, left, top, offset);
 
     if (draw_masked)
+    {
+        /* code path for drawing flat disabled icons without alpha channel */
         TOOLBAR_DrawMasked (himl, index, tbcd->nmcd.hdc, left + offset, top + offset, draw_flags);
+    }
+    else if (draw_desaturated)
+    {
+        /* code path for drawing disabled, alpha-blended (32bpp) icons */
+        IMAGELISTDRAWPARAMS imldp = {0};
+
+        imldp.cbSize = sizeof(imldp);
+        imldp.himl   = himl;
+        imldp.i      = index;
+        imldp.hdcDst = tbcd->nmcd.hdc,
+        imldp.x      = offset + left;
+        imldp.y      = offset + top;
+        imldp.rgbBk  = CLR_NONE;
+        imldp.rgbFg  = CLR_DEFAULT;
+        imldp.fStyle = ILD_TRANSPARENT;
+        imldp.fState = ILS_ALPHA | ILS_SATURATE;
+        imldp.Frame  = 192;
+
+        ImageList_DrawIndirect (&imldp);
+    }
     else
+    {
+        /* code path for drawing standard icons as-is */
         ImageList_Draw (himl, index, tbcd->nmcd.hdc, left + offset, top + offset, draw_flags);
+    }
 }
 
 /* draws a blank frame for a toolbar button */
@@ -884,14 +947,15 @@ TOOLBAR_DrawButton (const TOOLBAR_INFO *
                 InflateRect(&rcsep, -infoPtr->szPadding.cx, -infoPtr->szPadding.cy);
                 TOOLBAR_DrawFlatHorizontalSeparator (&rcsep, hdc, infoPtr);
             }
-	    else
-		TOOLBAR_DrawFlatSeparator (&rc, hdc, infoPtr);
-	}
-	else if (btnPtr->fsStyle != BTNS_SEP) {
-	    FIXME("Draw some kind of separator: fsStyle=%x\n",
-		  btnPtr->fsStyle);
-	}
-	return;
+            else {
+                TOOLBAR_DrawFlatSeparator (&rc, hdc, infoPtr);
+            }
+        }
+        else if (btnPtr->fsStyle != BTNS_SEP) {
+            FIXME("Draw some kind of separator: fsStyle=%x\n",
+              btnPtr->fsStyle);
+        }
+        return;
     }
 
     /* get a pointer to the text */
@@ -1028,7 +1092,11 @@ TOOLBAR_DrawButton (const TOOLBAR_INFO *
         }
     }
 
+#ifdef __REACTOS__
+    if (theme && !(dwItemCDFlag & TBCDRF_NOBACKGROUND))
+#else
     if (theme)
+#endif
     {
         int partId = drawSepDropDownArrow ? TP_SPLITBUTTON : TP_BUTTON;
         int stateId = TS_NORMAL;
@@ -1045,7 +1113,12 @@ TOOLBAR_DrawButton (const TOOLBAR_INFO *
             
         DrawThemeBackground (theme, hdc, partId, stateId, &rc, NULL);
     }
+
+#ifdef __REACTOS__
+    if (!theme)
+#else
     else
+#endif
         TOOLBAR_DrawFrame(infoPtr, &tbcd, &rc, dwItemCDFlag);
 
     if (drawSepDropDownArrow)
@@ -1571,9 +1644,14 @@ static inline SIZE TOOLBAR_MeasureButton
         /* ... add on the necessary padding */
         if (bValidImageList)
         {
+#ifdef __REACTOS__
+            sizeButton.cy += infoPtr->szPadding.cy;
+            if (!bHasBitmap)
+#else
             if (bHasBitmap)
                 sizeButton.cy += DEFPAD_CY;
             else
+#endif
                 sizeButton.cy += LISTPAD_CY;
         }
         else
@@ -1590,7 +1668,11 @@ static inline SIZE TOOLBAR_MeasureButton
     {
         if (bHasBitmap)
         {
+#ifdef __REACTOS__
+            sizeButton.cy = infoPtr->nBitmapHeight + infoPtr->szPadding.cy;
+#else
             sizeButton.cy = infoPtr->nBitmapHeight + DEFPAD_CY;
+#endif
             if (sizeString.cy > 0)
                 sizeButton.cy += 1 + sizeString.cy;
             sizeButton.cx = infoPtr->szPadding.cx +
@@ -1695,7 +1777,14 @@ TOOLBAR_LayoutToolbar(TOOLBAR_INFO *info
 	{
             if (btnPtr->cx)
               cx = btnPtr->cx;
+#ifdef __REACTOS__
+            /* Revert Wine Commit 5b7b911 as it breaks Explorer Toolbar Buttons
+               FIXME: Revisit this when the bug is fixed. CORE-9970 */
+            else if ((infoPtr->dwExStyle & TBSTYLE_EX_MIXEDBUTTONS) || 
+                (btnPtr->fsStyle & BTNS_AUTOSIZE))
+#else
             else if (btnPtr->fsStyle & BTNS_AUTOSIZE)
+#endif
             {
               SIZE sz;
 	      HDC hdc;
@@ -1954,6 +2043,17 @@ TOOLBAR_RelayEvent (HWND hwndTip, HWND h
     SendMessageW (hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);
 }
 
+#ifdef __REACTOS__
+static LRESULT
+TOOLBAR_ThemeChanged(HWND hwnd)
+{
+    HTHEME theme = GetWindowTheme(hwnd);
+    CloseThemeData(theme);
+    OpenThemeData(hwnd, themeClass);
+    return 0;
+}
+#endif
+
 static void
 TOOLBAR_TooltipAddTool(const TOOLBAR_INFO *infoPtr, const TBUTTON_INFO *button)
 {
@@ -3535,6 +3635,36 @@ TOOLBAR_GetMaxSize (const TOOLBAR_INFO *
     return TRUE;
 }
 
+#ifdef __REACTOS__
+static LRESULT
+TOOLBAR_GetMetrics(const TOOLBAR_INFO *infoPtr, TBMETRICS *pMetrics)
+{
+    if (pMetrics == NULL)
+        return FALSE;
+
+    /* TODO: check if cbSize is a valid value */
+
+    if (pMetrics->dwMask & TBMF_PAD)
+    {
+        pMetrics->cxPad = infoPtr->szPadding.cx;
+        pMetrics->cyPad = infoPtr->szPadding.cy;
+    }
+
+    if (pMetrics->dwMask & TBMF_BARPAD)
+    {
+        pMetrics->cxBarPad = infoPtr->szBarPadding.cx;
+        pMetrics->cyBarPad = infoPtr->szBarPadding.cy;
+    }
+
+    if (pMetrics->dwMask & TBMF_BUTTONSPACING)
+    {
+        pMetrics->cxButtonSpacing = infoPtr->szSpacing.cx;
+        pMetrics->cyButtonSpacing = infoPtr->szSpacing.cy;
+    }
+
+    return TRUE;
+}
+#endif
 
 /* << TOOLBAR_GetObject >> */
 
@@ -4790,6 +4920,44 @@ TOOLBAR_SetMaxTextRows (TOOLBAR_INFO *in
     return TRUE;
 }
 
+#ifdef __REACTOS__
+static LRESULT
+TOOLBAR_SetMetrics(TOOLBAR_INFO *infoPtr, TBMETRICS *pMetrics)
+{
+    BOOL changed = FALSE;
+
+    if (!pMetrics)
+        return FALSE;
+
+    /* TODO: check if cbSize is a valid value */
+
+    if (pMetrics->dwMask & TBMF_PAD)
+    {
+        infoPtr->szPadding.cx = pMetrics->cxPad;
+        infoPtr->szPadding.cy = pMetrics->cyPad;
+        changed = TRUE;
+    }
+
+    if (pMetrics->dwMask & TBMF_PAD)
+    {
+        infoPtr->szBarPadding.cx = pMetrics->cxBarPad;
+        infoPtr->szBarPadding.cy = pMetrics->cyBarPad;
+        changed = TRUE;
+    }
+
+    if (pMetrics->dwMask & TBMF_BUTTONSPACING)
+    {
+        infoPtr->szSpacing.cx = pMetrics->cxButtonSpacing;
+        infoPtr->szSpacing.cy = pMetrics->cyButtonSpacing;
+        changed = TRUE;
+    }
+
+    if (changed)
+        TOOLBAR_CalcToolbar(infoPtr);
+
+    return TRUE;
+}
+#endif
 
 /* MSDN gives slightly wrong info on padding.
  * 1. It is not only used on buttons with the BTNS_AUTOSIZE style
@@ -6030,6 +6198,10 @@ TOOLBAR_NCCreate (HWND hwnd, WPARAM wPar
     infoPtr->clrBtnShadow = CLR_DEFAULT;
     infoPtr->szPadding.cx = DEFPAD_CX;
     infoPtr->szPadding.cy = DEFPAD_CY;
+#ifdef __REACTOS__
+    infoPtr->szSpacing.cx = DEFSPACE_CX;
+    infoPtr->szSpacing.cy = DEFSPACE_CY;
+#endif
     infoPtr->iListGap = DEFLISTGAP;
     infoPtr->iTopMargin = default_top_margin(infoPtr);
     infoPtr->dwStyle = lpcs->style;
@@ -6439,7 +6611,7 @@ TOOLBAR_SysColorChange (void)
     return 0;
 }
 
-
+#ifndef __REACTOS__
 /* update theme after a WM_THEMECHANGED message */
 static LRESULT theme_changed (HWND hwnd)
 {
@@ -6448,7 +6620,7 @@ static LRESULT theme_changed (HWND hwnd)
     OpenThemeData (hwnd, themeClass);
     return 0;
 }
-
+#endif
 
 static LRESULT WINAPI
 ToolbarWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
@@ -6553,6 +6725,10 @@ ToolbarWindowProc (HWND hwnd, UINT uMsg,
 
 	case TB_GETMAXSIZE:
 	    return TOOLBAR_GetMaxSize (infoPtr, (LPSIZE)lParam);
+#ifdef __REACTOS__
+	case TB_GETMETRICS:
+	    return TOOLBAR_GetMetrics (infoPtr, (TBMETRICS*)lParam);
+#endif
 
 /*	case TB_GETOBJECT:			*/ /* 4.71 */
 
@@ -6694,6 +6870,11 @@ ToolbarWindowProc (HWND hwnd, UINT uMsg,
 	case TB_SETMAXTEXTROWS:
 	    return TOOLBAR_SetMaxTextRows (infoPtr, wParam);
 
+#ifdef __REACTOS__
+	case TB_SETMETRICS:
+	    return TOOLBAR_SetMetrics (infoPtr, (TBMETRICS*)lParam);
+#endif
+
 	case TB_SETPADDING:
 	    return TOOLBAR_SetPadding (infoPtr, lParam);
 
@@ -6835,7 +7016,11 @@ ToolbarWindowProc (HWND hwnd, UINT uMsg,
 	    return TOOLBAR_SysColorChange ();
             
         case WM_THEMECHANGED:
+#ifdef __REACTOS__
+        return TOOLBAR_ThemeChanged(hwnd);
+#else
             return theme_changed (hwnd);
+#endif
 
 /*	case WM_WININICHANGE: */
 
diff -pudN e:\wine\dlls\comctl32/tooltips.c e:\reactos\dll\win32\comctl32/tooltips.c
--- e:\wine\dlls\comctl32/tooltips.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/tooltips.c	2016-06-05 19:39:01 +0100
@@ -2013,7 +2013,36 @@ TOOLTIPS_NCHitTest (const TOOLTIPS_INFO 
 static LRESULT
 TOOLTIPS_NotifyFormat (TOOLTIPS_INFO *infoPtr, WPARAM wParam, LPARAM lParam)
 {
+#ifdef __REACTOS__
+    TTTOOL_INFO *toolPtr = infoPtr->tools;
+    LRESULT nResult;
+
+    TRACE("infoPtr=%p wParam=%lx lParam=%p\n", infoPtr, wParam, (PVOID)lParam);
+
+    if (lParam == NF_QUERY) {
+        if (toolPtr->bNotifyUnicode) {
+            return NFR_UNICODE;
+        } else {
+            return NFR_ANSI;
+        }
+    }
+    else if (lParam == NF_REQUERY) {
+        nResult = SendMessageW (toolPtr->hwnd, WM_NOTIFYFORMAT,
+                    (WPARAM)infoPtr->hwndSelf, (LPARAM)NF_QUERY);
+        if (nResult == NFR_ANSI) {
+            toolPtr->bNotifyUnicode = FALSE;
+            TRACE(" -- WM_NOTIFYFORMAT returns: NFR_ANSI\n");
+        } else if (nResult == NFR_UNICODE) {
+            toolPtr->bNotifyUnicode = TRUE;
+            TRACE(" -- WM_NOTIFYFORMAT returns: NFR_UNICODE\n");
+        } else {
+            TRACE (" -- WM_NOTIFYFORMAT returns: error!\n");
+        }
+        return nResult;
+    }
+#else
     FIXME ("hwnd=%p wParam=%lx lParam=%lx\n", infoPtr->hwndSelf, wParam, lParam);
+#endif
 
     return 0;
 }
diff -pudN e:\wine\dlls\comctl32/treeview.c e:\reactos\dll\win32\comctl32/treeview.c
--- e:\wine\dlls\comctl32/treeview.c	2016-05-31 18:00:02 +0100
+++ e:\reactos\dll\win32\comctl32/treeview.c	2016-03-01 20:00:54 +0100
@@ -2888,7 +2888,14 @@ TREEVIEW_Refresh(TREEVIEW_INFO *infoPtr,
 	}
     }
 
+    //
+    // FIXME: This is correct, but is causes and infinite loop of WM_PAINT
+    // messages, resulting in continuous painting of the scroll bar in reactos.
+    // Comment out until the real bug is found. CORE-4912
+    //
+#ifndef __REACTOS__
     TREEVIEW_UpdateScrollBars(infoPtr);
+#endif
 
     if (infoPtr->cdmode & CDRF_NOTIFYPOSTPAINT)
 	infoPtr->cdmode =
