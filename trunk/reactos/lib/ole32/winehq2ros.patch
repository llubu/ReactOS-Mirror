? Makefile.ros
? Makefile.ros-template
? winehq2ros.patch
Index: antimoniker.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/antimoniker.c,v
retrieving revision 1.16
diff -u -r1.16 antimoniker.c
--- antimoniker.c	11 Sep 2003 03:06:25 -0000	1.16
+++ antimoniker.c	2 Jan 2004 19:11:37 -0000
@@ -287,9 +287,9 @@
 
     /* Normaly the sizemax must be the  size of DWORD ! but I tested this function it ususlly return 16 bytes */
     /* more than the number of bytes used by AntiMoniker::Save function */
-    pcbSize->s.LowPart =  sizeof(DWORD)+16;
+    pcbSize->u.LowPart =  sizeof(DWORD)+16;
 
-    pcbSize->s.HighPart=0;
+    pcbSize->u.HighPart=0;
 
     return S_OK;
 }
Index: compobj.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/compobj.c,v
retrieving revision 1.84
diff -u -r1.84 compobj.c
--- compobj.c	6 Oct 2003 21:03:32 -0000	1.84
+++ compobj.c	2 Jan 2004 19:11:38 -0000
@@ -565,7 +565,7 @@
 /*****************************************************************************/
 
 HRESULT WINAPI CLSIDFromString(
-	LPCOLESTR idstr,	/* [in] string representation of GUID */
+	LPOLESTR idstr,		/* [in] string representation of GUID */
 	CLSID *id )		/* [out] GUID represented by above string */
 {
     char xid[40];
@@ -1006,10 +1006,10 @@
     hres = IStream_Stat(pStm,&ststg,0);
     if (hres) return hres;
 
-    buflen = ststg.cbSize.s.LowPart;
+    buflen = ststg.cbSize.u.LowPart;
     buffer = HeapAlloc(GetProcessHeap(),0,buflen);
-    seekto.s.LowPart = 0;
-    seekto.s.HighPart = 0;
+    seekto.u.LowPart = 0;
+    seekto.u.HighPart = 0;
     hres = IStream_Seek(pStm,seekto,SEEK_SET,&newpos);
     if (hres) {
 	FIXME("IStream_Seek failed, %lx\n",hres);
Index: compositemoniker.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/compositemoniker.c,v
retrieving revision 1.25
diff -u -r1.25 compositemoniker.c
--- compositemoniker.c	30 Sep 2003 00:24:08 -0000	1.25
+++ compositemoniker.c	2 Jan 2004 19:11:39 -0000
@@ -442,8 +442,8 @@
     if (pcbSize!=NULL)
         return E_POINTER;
 
-    pcbSize->s.LowPart =0;
-    pcbSize->s.HighPart=0;
+    pcbSize->u.LowPart =0;
+    pcbSize->u.HighPart=0;
 
     IMoniker_Enum(iface,TRUE,&enumMk);
 
@@ -453,8 +453,8 @@
 
         IMoniker_Release(pmk);
 
-        pcbSize->s.LowPart +=ptmpSize.s.LowPart;
-        pcbSize->s.HighPart+=ptmpSize.s.HighPart;
+        pcbSize->u.LowPart +=ptmpSize.u.LowPart;
+        pcbSize->u.HighPart+=ptmpSize.u.HighPart;
     }
 
     IEnumMoniker_Release(enumMk);
Index: datacache.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/datacache.c,v
retrieving revision 1.21
diff -u -r1.21 datacache.c
--- datacache.c	11 Sep 2003 03:06:25 -0000	1.21
+++ datacache.c	2 Jan 2004 19:11:40 -0000
@@ -696,7 +696,7 @@
     LPCWSTR name = elem->pwcsName;
 
     return (elem->type == STGTY_STREAM)
-	&& (elem->cbSize.s.LowPart >= sizeof(PresentationDataHeader))
+	&& (elem->cbSize.u.LowPart >= sizeof(PresentationDataHeader))
 	&& (strlenW(name) == 11)
 	&& (strncmpW(name, OlePres, 8) == 0)
 	&& (name[8] >= '0') && (name[8] <= '9')
@@ -765,8 +765,8 @@
 		{
 		    /* Rewind the stream before returning it. */
 		    LARGE_INTEGER offset;
-		    offset.s.LowPart = 0;
-		    offset.s.HighPart = 0;
+		    offset.u.LowPart = 0;
+		    offset.u.HighPart = 0;
 		    IStream_Seek(pStm, offset, STREAM_SEEK_SET, NULL);
 
 		    *ppStm = pStm;
@@ -835,8 +835,8 @@
   /*
    * Skip the header
    */
-  offset.s.HighPart = 0;
-  offset.s.LowPart  = sizeof(PresentationDataHeader);
+  offset.u.HighPart = 0;
+  offset.u.LowPart  = sizeof(PresentationDataHeader);
 
   hres = IStream_Seek(
            presStream,
@@ -844,14 +844,14 @@
 	   STREAM_SEEK_SET,
 	   NULL);
 
-  streamInfo.cbSize.s.LowPart -= offset.s.LowPart;
+  streamInfo.cbSize.u.LowPart -= offset.u.LowPart;
 
   /*
    * Allocate a buffer for the metafile bits.
    */
   metafileBits = HeapAlloc(GetProcessHeap(),
 			   0,
-			   streamInfo.cbSize.s.LowPart);
+			   streamInfo.cbSize.u.LowPart);
 
   /*
    * Read the metafile bits.
@@ -859,7 +859,7 @@
   hres = IStream_Read(
 	   presStream,
 	   metafileBits,
-	   streamInfo.cbSize.s.LowPart,
+	   streamInfo.cbSize.u.LowPart,
 	   NULL);
 
   /*
@@ -867,7 +867,7 @@
    */
   if (SUCCEEDED(hres))
   {
-    newMetafile = SetMetaFileBitsEx(streamInfo.cbSize.s.LowPart, metafileBits);
+    newMetafile = SetMetaFileBitsEx(streamInfo.cbSize.u.LowPart, metafileBits);
   }
 
   /*
Index: filemoniker.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/filemoniker.c,v
retrieving revision 1.27
diff -u -r1.27 filemoniker.c
--- filemoniker.c	1 Oct 2003 03:14:29 -0000	1.27
+++ filemoniker.c	2 Jan 2004 19:11:42 -0000
@@ -459,8 +459,8 @@
                sizeof(WORD)+            /* constant : 0x3 */
                len*sizeof(WCHAR);       /* unicde filePath string */
 
-    pcbSize->s.LowPart=sizeMAx;
-    pcbSize->s.HighPart=0;
+    pcbSize->u.LowPart=sizeMAx;
+    pcbSize->u.HighPart=0;
 
     return S_OK;
 }
Index: git.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/git.c,v
retrieving revision 1.8
diff -u -r1.8 git.c
--- git.c	9 Sep 2003 19:39:31 -0000	1.8
+++ git.c	2 Jan 2004 19:11:42 -0000
@@ -309,8 +309,8 @@
   }
   
   /* rewind stream, in case it's used again */
-  move.s.LowPart = 0;
-  move.s.HighPart = 0;
+  move.u.LowPart = 0;
+  move.u.HighPart = 0;
   IStream_Seek(entry->stream, move, STREAM_SEEK_SET, NULL);
 
   /* addref it */
Index: hglobalstream.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/hglobalstream.c,v
retrieving revision 1.20
diff -u -r1.20 hglobalstream.c
--- hglobalstream.c	26 Nov 2003 03:36:18 -0000	1.20
+++ hglobalstream.c	2 Jan 2004 19:11:42 -0000
@@ -283,14 +283,14 @@
     /*
      * Start the stream at the beginning.
      */
-    newStream->currentPosition.s.HighPart = 0;
-    newStream->currentPosition.s.LowPart = 0;
+    newStream->currentPosition.u.HighPart = 0;
+    newStream->currentPosition.u.LowPart = 0;
 
     /*
      * Initialize the size of the stream to the size of the handle.
      */
-    newStream->streamSize.s.HighPart = 0;
-    newStream->streamSize.s.LowPart  = GlobalSize(newStream->supportHandle);
+    newStream->streamSize.u.HighPart = 0;
+    newStream->streamSize.u.LowPart  = GlobalSize(newStream->supportHandle);
   }
 
   return newStream;
@@ -446,19 +446,19 @@
    * Using the known size of the stream, calculate the number of bytes
    * to read from the block chain
    */
-  bytesToReadFromBuffer = min( This->streamSize.s.LowPart - This->currentPosition.s.LowPart, cb);
+  bytesToReadFromBuffer = min( This->streamSize.u.LowPart - This->currentPosition.u.LowPart, cb);
 
   /*
    * Lock the buffer in position and copy the data.
    */
   supportBuffer = GlobalLock(This->supportHandle);
 
-  memcpy(pv, (char *) supportBuffer+This->currentPosition.s.LowPart, bytesToReadFromBuffer);
+  memcpy(pv, (char *) supportBuffer+This->currentPosition.u.LowPart, bytesToReadFromBuffer);
 
   /*
    * Move the current position to the new position
    */
-  This->currentPosition.s.LowPart+=bytesToReadFromBuffer;
+  This->currentPosition.u.LowPart+=bytesToReadFromBuffer;
 
   /*
    * Return the number of bytes read.
@@ -519,14 +519,14 @@
   }
   else
   {
-    newSize.s.HighPart = 0;
-    newSize.s.LowPart = This->currentPosition.s.LowPart + cb;
+    newSize.u.HighPart = 0;
+    newSize.u.LowPart = This->currentPosition.u.LowPart + cb;
   }
 
   /*
    * Verify if we need to grow the stream
    */
-  if (newSize.s.LowPart > This->streamSize.s.LowPart)
+  if (newSize.u.LowPart > This->streamSize.u.LowPart)
   {
     /* grow stream */
    IStream_SetSize(iface, newSize);
@@ -537,12 +537,12 @@
    */
   supportBuffer = GlobalLock(This->supportHandle);
 
-  memcpy((char *) supportBuffer+This->currentPosition.s.LowPart, pv, cb);
+  memcpy((char *) supportBuffer+This->currentPosition.u.LowPart, pv, cb);
 
   /*
    * Move the current position to the new position
    */
-  This->currentPosition.s.LowPart+=cb;
+  This->currentPosition.u.LowPart+=cb;
 
   /*
    * Return the number of bytes read.
@@ -576,7 +576,7 @@
   ULARGE_INTEGER newPosition;
 
   TRACE("(%p, %ld, %ld, %p)\n", iface,
-	dlibMove.s.LowPart, dwOrigin, plibNewPosition);
+	dlibMove.u.LowPart, dwOrigin, plibNewPosition);
 
   /*
    * The file pointer is moved depending on the given "function"
@@ -585,8 +585,8 @@
   switch (dwOrigin)
   {
     case STREAM_SEEK_SET:
-      newPosition.s.HighPart = 0;
-      newPosition.s.LowPart = 0;
+      newPosition.u.HighPart = 0;
+      newPosition.u.LowPart = 0;
       break;
     case STREAM_SEEK_CUR:
       newPosition = This->currentPosition;
@@ -628,27 +628,27 @@
   HGLOBALStreamImpl* const This=(HGLOBALStreamImpl*)iface;
   HGLOBAL supportHandle;
 
-  TRACE("(%p, %ld)\n", iface, libNewSize.s.LowPart);
+  TRACE("(%p, %ld)\n", iface, libNewSize.u.LowPart);
 
   /*
    * As documented.
    */
-  if (libNewSize.s.HighPart != 0)
+  if (libNewSize.u.HighPart != 0)
     return STG_E_INVALIDFUNCTION;
 
-  if (This->streamSize.s.LowPart == libNewSize.s.LowPart)
+  if (This->streamSize.u.LowPart == libNewSize.u.LowPart)
     return S_OK;
 
   /*
    * Re allocate the HGlobal to fit the new size of the stream.
    */
-  supportHandle = GlobalReAlloc(This->supportHandle, libNewSize.s.LowPart, 0);
+  supportHandle = GlobalReAlloc(This->supportHandle, libNewSize.u.LowPart, 0);
 
   if (supportHandle == 0)
     return STG_E_MEDIUMFULL;
 
   This->supportHandle = supportHandle;
-  This->streamSize.s.LowPart = libNewSize.s.LowPart;
+  This->streamSize.u.LowPart = libNewSize.u.LowPart;
 
   return S_OK;
 }
@@ -674,7 +674,7 @@
   ULARGE_INTEGER totalBytesWritten;
 
   TRACE("(%p, %p, %ld, %p, %p)\n", iface, pstm,
-	cb.s.LowPart, pcbRead, pcbWritten);
+	cb.u.LowPart, pcbRead, pcbWritten);
 
   /*
    * Sanity check
@@ -682,28 +682,28 @@
   if ( pstm == 0 )
     return STG_E_INVALIDPOINTER;
 
-  totalBytesRead.s.LowPart = totalBytesRead.s.HighPart = 0;
-  totalBytesWritten.s.LowPart = totalBytesWritten.s.HighPart = 0;
+  totalBytesRead.u.LowPart = totalBytesRead.u.HighPart = 0;
+  totalBytesWritten.u.LowPart = totalBytesWritten.u.HighPart = 0;
 
   /*
    * use stack to store data temporarly
    * there is surely more performant way of doing it, for now this basic
    * implementation will do the job
    */
-  while ( cb.s.LowPart > 0 )
+  while ( cb.u.LowPart > 0 )
   {
-    if ( cb.s.LowPart >= 128 )
+    if ( cb.u.LowPart >= 128 )
       copySize = 128;
     else
-      copySize = cb.s.LowPart;
+      copySize = cb.u.LowPart;
 
     IStream_Read(iface, tmpBuffer, copySize, &bytesRead);
 
-    totalBytesRead.s.LowPart += bytesRead;
+    totalBytesRead.u.LowPart += bytesRead;
 
     IStream_Write(pstm, tmpBuffer, bytesRead, &bytesWritten);
 
-    totalBytesWritten.s.LowPart += bytesWritten;
+    totalBytesWritten.u.LowPart += bytesWritten;
 
     /*
      * Check that read & write operations were succesfull
@@ -715,9 +715,9 @@
     }
 
     if (bytesRead!=copySize)
-      cb.s.LowPart = 0;
+      cb.u.LowPart = 0;
     else
-      cb.s.LowPart -= bytesRead;
+      cb.u.LowPart -= bytesRead;
   }
 
   /*
@@ -725,14 +725,14 @@
    */
   if (pcbRead)
   {
-    pcbRead->s.LowPart = totalBytesRead.s.LowPart;
-    pcbRead->s.HighPart = totalBytesRead.s.HighPart;
+    pcbRead->u.LowPart = totalBytesRead.u.LowPart;
+    pcbRead->u.HighPart = totalBytesRead.u.HighPart;
   }
 
   if (pcbWritten)
   {
-    pcbWritten->s.LowPart = totalBytesWritten.s.LowPart;
-    pcbWritten->s.HighPart = totalBytesWritten.s.HighPart;
+    pcbWritten->u.LowPart = totalBytesWritten.u.LowPart;
+    pcbWritten->u.HighPart = totalBytesWritten.u.HighPart;
   }
   return hr;
 }
Index: ifs.h
===================================================================
RCS file: /home/wine/wine/dlls/ole32/ifs.h,v
retrieving revision 1.10
diff -u -r1.10 ifs.h
--- ifs.h	14 Oct 2003 20:23:01 -0000	1.10
+++ ifs.h	2 Jan 2004 19:11:42 -0000
@@ -31,6 +31,7 @@
 
 typedef struct IMalloc16 IMalloc16, *LPMALLOC16;
 
+#undef INTERFACE
 #define INTERFACE IMalloc16
 #define IMalloc16_METHODS \
     IUnknown_METHODS \
Index: itemmoniker.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/itemmoniker.c,v
retrieving revision 1.21
diff -u -r1.21 itemmoniker.c
--- itemmoniker.c	11 Sep 2003 03:06:25 -0000	1.21
+++ itemmoniker.c	2 Jan 2004 19:11:43 -0000
@@ -363,13 +363,13 @@
 
     /* for more details see ItemMonikerImpl_Save coments */
 
-    pcbSize->s.LowPart =  sizeof(DWORD) + /* DWORD which contains delimiter length */
+    pcbSize->u.LowPart =  sizeof(DWORD) + /* DWORD which contains delimiter length */
                         delimiterLength + /* item delimiter string */
                         sizeof(DWORD) + /* DWORD which contains item name length */
                         nameLength + /* item name string */
                         34; /* this constant was added ! because when I tested this function it usually */
                             /*  returns 34 bytes more than the number of bytes used by IMoniker::Save function */
-    pcbSize->s.HighPart=0;
+    pcbSize->u.HighPart=0;
 
     return S_OK;
 }
Index: memlockbytes.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/memlockbytes.c,v
retrieving revision 1.16
diff -u -r1.16 memlockbytes.c
--- memlockbytes.c	26 Nov 2003 03:36:18 -0000	1.16
+++ memlockbytes.c	2 Jan 2004 19:11:43 -0000
@@ -200,19 +200,19 @@
      ERR("Cannot ILockBytes_Stat, %lx\n",hres);
      return hres;
   }
-  FIXME("cbSize is %ld\n",stbuf.cbSize.s.LowPart);
-  *phglobal = GlobalAlloc( GMEM_MOVEABLE|GMEM_SHARE, stbuf.cbSize.s.LowPart);
+  FIXME("cbSize is %ld\n",stbuf.cbSize.u.LowPart);
+  *phglobal = GlobalAlloc( GMEM_MOVEABLE|GMEM_SHARE, stbuf.cbSize.u.LowPart);
   if (!*phglobal)
     return E_INVALIDARG;
   memset(&start,0,sizeof(start));
-  hres = ILockBytes_ReadAt(plkbyt, start, GlobalLock(*phglobal), stbuf.cbSize.s.LowPart, &xread);
+  hres = ILockBytes_ReadAt(plkbyt, start, GlobalLock(*phglobal), stbuf.cbSize.u.LowPart, &xread);
   GlobalUnlock(*phglobal);
   if (hres != S_OK) {
     FIXME("%p->ReadAt failed with %lx\n",plkbyt,hres);
     return hres;
   }
-  if (stbuf.cbSize.s.LowPart != xread) {
-    FIXME("Read size is not requested size %ld vs %ld?\n",stbuf.cbSize.s.LowPart, xread);
+  if (stbuf.cbSize.u.LowPart != xread) {
+    FIXME("Read size is not requested size %ld vs %ld?\n",stbuf.cbSize.u.LowPart, xread);
   }
   return S_OK;
 }
@@ -264,8 +264,8 @@
     /*
      * Initialize the size of the array to the size of the handle.
      */
-    newLockBytes->byteArraySize.s.HighPart = 0;
-    newLockBytes->byteArraySize.s.LowPart  = GlobalSize(
+    newLockBytes->byteArraySize.u.HighPart = 0;
+    newLockBytes->byteArraySize.u.LowPart  = GlobalSize(
                                               newLockBytes->supportHandle);
   }
 
@@ -414,15 +414,15 @@
   /*
    * Make sure the offset is valid.
    */
-  if (ulOffset.s.LowPart > This->byteArraySize.s.LowPart)
+  if (ulOffset.u.LowPart > This->byteArraySize.u.LowPart)
     return E_FAIL;
 
   /*
    * Using the known size of the array, calculate the number of bytes
    * to read.
    */
-  bytesToReadFromBuffer = min(This->byteArraySize.s.LowPart -
-                              ulOffset.s.LowPart, cb);
+  bytesToReadFromBuffer = min(This->byteArraySize.u.LowPart -
+                              ulOffset.u.LowPart, cb);
 
   /*
    * Lock the buffer in position and copy the data.
@@ -430,7 +430,7 @@
   supportBuffer = GlobalLock(This->supportHandle);
 
   memcpy(pv,
-         (char *) supportBuffer + ulOffset.s.LowPart,
+         (char *) supportBuffer + ulOffset.u.LowPart,
          bytesToReadFromBuffer);
 
   /*
@@ -489,14 +489,14 @@
   }
   else
   {
-    newSize.s.HighPart = 0;
-    newSize.s.LowPart = ulOffset.s.LowPart + cb;
+    newSize.u.HighPart = 0;
+    newSize.u.LowPart = ulOffset.u.LowPart + cb;
   }
 
   /*
    * Verify if we need to grow the stream
    */
-  if (newSize.s.LowPart > This->byteArraySize.s.LowPart)
+  if (newSize.u.LowPart > This->byteArraySize.u.LowPart)
   {
     /* grow stream */
     if (HGLOBALLockBytesImpl_SetSize(iface, newSize) == STG_E_MEDIUMFULL)
@@ -508,7 +508,7 @@
    */
   supportBuffer = GlobalLock(This->supportHandle);
 
-  memcpy((char *) supportBuffer + ulOffset.s.LowPart, pv, cb);
+  memcpy((char *) supportBuffer + ulOffset.u.LowPart, pv, cb);
 
   /*
    * Return the number of bytes written.
@@ -550,22 +550,22 @@
   /*
    * As documented.
    */
-  if (libNewSize.s.HighPart != 0)
+  if (libNewSize.u.HighPart != 0)
     return STG_E_INVALIDFUNCTION;
 
-  if (This->byteArraySize.s.LowPart == libNewSize.s.LowPart)
+  if (This->byteArraySize.u.LowPart == libNewSize.u.LowPart)
     return S_OK;
 
   /*
    * Re allocate the HGlobal to fit the new size of the stream.
    */
-  supportHandle = GlobalReAlloc(This->supportHandle, libNewSize.s.LowPart, 0);
+  supportHandle = GlobalReAlloc(This->supportHandle, libNewSize.u.LowPart, 0);
 
   if (supportHandle == 0)
     return STG_E_MEDIUMFULL;
 
   This->supportHandle = supportHandle;
-  This->byteArraySize.s.LowPart = libNewSize.s.LowPart;
+  This->byteArraySize.u.LowPart = libNewSize.u.LowPart;
 
   return S_OK;
 }
Index: ole2.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/ole2.c,v
retrieving revision 1.48
diff -u -r1.48 ole2.c
--- ole2.c	8 Dec 2003 22:46:08 -0000	1.48
+++ ole2.c	2 Jan 2004 19:11:45 -0000
@@ -1419,6 +1419,7 @@
  */
 BOOL WINAPI IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD* lpwCmd)
 {
+#if 0 /* Not implemented for ReactOS */
     /* YES, Accel16! */
     LPACCEL16 lpAccelTbl;
     int i;
@@ -1485,6 +1486,9 @@
 found:
     if(lpwCmd) *lpwCmd = lpAccelTbl[i].cmd;
     return TRUE;
+#else
+    return FALSE;
+#endif
 }
 
 /***********************************************************************
Index: ole2stubs.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/ole2stubs.c,v
retrieving revision 1.34
diff -u -r1.34 ole2stubs.c
--- ole2stubs.c	8 Dec 2003 22:46:08 -0000	1.34
+++ ole2stubs.c	2 Jan 2004 19:11:45 -0000
@@ -47,11 +47,11 @@
 /******************************************************************************
  *              OleDuplicateData        [OLE32.@]
  */
-HRESULT WINAPI OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat,
+HANDLE WINAPI OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat,
 	                          UINT uiFlags)
 {
     FIXME("(%p,%x,%x), stub!\n", hSrc, cfFormat, uiFlags);
-    return E_NOTIMPL;
+    return NULL;
 }
 
 
Index: oleproxy.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/oleproxy.c,v
retrieving revision 1.12
diff -u -r1.12 oleproxy.c
--- oleproxy.c	14 Oct 2003 05:24:21 -0000	1.12
+++ oleproxy.c	2 Jan 2004 19:11:45 -0000
@@ -184,14 +184,14 @@
 	    return hres;
 	}
 
-	msg->cbBuffer = ststg.cbSize.s.LowPart;
+	msg->cbBuffer = ststg.cbSize.u.LowPart;
 
 	if (msg->Buffer)
-	    msg->Buffer = HeapReAlloc(GetProcessHeap(),0,msg->Buffer,ststg.cbSize.s.LowPart);
+	    msg->Buffer = HeapReAlloc(GetProcessHeap(),0,msg->Buffer,ststg.cbSize.u.LowPart);
 	else
-	    msg->Buffer = HeapAlloc(GetProcessHeap(),0,ststg.cbSize.s.LowPart);
+	    msg->Buffer = HeapAlloc(GetProcessHeap(),0,ststg.cbSize.u.LowPart);
 
-	seekto.s.LowPart = 0;seekto.s.HighPart = 0;
+	seekto.u.LowPart = 0;seekto.u.HighPart = 0;
 	hres = IStream_Seek(pStm,seekto,SEEK_SET,&newpos);
 	if (hres) {
 	    FIXME("IStream_Seek failed, %lx\n",hres);
Index: rpc.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/rpc.c,v
retrieving revision 1.13
diff -u -r1.13 rpc.c
--- rpc.c	14 Oct 2003 05:24:21 -0000	1.13
+++ rpc.c	2 Jan 2004 19:11:45 -0000
@@ -547,7 +547,7 @@
   if (hres) return hres;
   hres = IStream_Write(pStm,marshalbuffer,bufferlen,&res);
   if (hres) goto out;
-  seekto.s.LowPart = 0;seekto.s.HighPart = 0;
+  seekto.u.LowPart = 0;seekto.u.HighPart = 0;
   hres = IStream_Seek(pStm,seekto,SEEK_SET,&newpos);
   hres = CoUnmarshalInterface(pStm,&IID_IClassFactory,ppv);
 out:
Index: stg_bigblockfile.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/stg_bigblockfile.c,v
retrieving revision 1.11
diff -u -r1.11 stg_bigblockfile.c
--- stg_bigblockfile.c	9 Sep 2003 19:39:31 -0000	1.11
+++ stg_bigblockfile.c	2 Jan 2004 19:11:46 -0000
@@ -236,12 +236,12 @@
     return FALSE;
   }
 
-  This->filesize.s.LowPart = GetFileSize(This->hfile,
-					 &This->filesize.s.HighPart);
+  This->filesize.u.LowPart = GetFileSize(This->hfile,
+					 &This->filesize.u.HighPart);
 
   This->maplist = NULL;
 
-  TRACE("file len %lu\n", This->filesize.s.LowPart);
+  TRACE("file len %lu\n", This->filesize.u.LowPart);
 
   return TRUE;
 }
@@ -273,12 +273,12 @@
    */
   ILockBytes_AddRef(This->pLkbyt);
 
-  This->filesize.s.LowPart = GlobalSize(This->hbytearray);
-  This->filesize.s.HighPart = 0;
+  This->filesize.u.LowPart = GlobalSize(This->hbytearray);
+  This->filesize.u.HighPart = 0;
 
   This->pbytearray = GlobalLock(This->hbytearray);
 
-  TRACE("mem on %p len %lu\n", This->pbytearray, This->filesize.s.LowPart);
+  TRACE("mem on %p len %lu\n", This->pbytearray, This->filesize.u.LowPart);
 
   return TRUE;
 }
@@ -333,10 +333,10 @@
    *
    */
   if (This->blocksize * (index + 1)
-      > ROUND_UP(This->filesize.s.LowPart, This->blocksize))
+      > ROUND_UP(This->filesize.u.LowPart, This->blocksize))
   {
     TRACE("out of range %lu vs %lu\n", This->blocksize * (index + 1),
-	  This->filesize.s.LowPart);
+	  This->filesize.u.LowPart);
     return NULL;
   }
 
@@ -363,12 +363,12 @@
   /*
    * make sure that the block physically exists
    */
-  if ((This->blocksize * (index + 1)) > This->filesize.s.LowPart)
+  if ((This->blocksize * (index + 1)) > This->filesize.u.LowPart)
   {
     ULARGE_INTEGER newSize;
 
-    newSize.s.HighPart = 0;
-    newSize.s.LowPart = This->blocksize * (index + 1);
+    newSize.u.HighPart = 0;
+    newSize.u.LowPart = This->blocksize * (index + 1);
 
     BIGBLOCKFILE_SetSize(This, newSize);
   }
@@ -404,10 +404,10 @@
  */
 void BIGBLOCKFILE_SetSize(LPBIGBLOCKFILE This, ULARGE_INTEGER newSize)
 {
-  if (This->filesize.s.LowPart == newSize.s.LowPart)
+  if (This->filesize.u.LowPart == newSize.u.LowPart)
     return;
 
-  TRACE("from %lu to %lu\n", This->filesize.s.LowPart, newSize.s.LowPart);
+  TRACE("from %lu to %lu\n", This->filesize.u.LowPart, newSize.u.LowPart);
   /*
    * unmap all views, must be done before call to SetEndFile
    */
@@ -436,7 +436,7 @@
      * This hack is only needed when saving to smbfs.
      */
     memset(buf, '0', 10);
-    SetFilePointer(This->hfile, newSize.s.LowPart, NULL, FILE_BEGIN);
+    SetFilePointer(This->hfile, newSize.u.LowPart, NULL, FILE_BEGIN);
     WriteFile(This->hfile, buf, 10, NULL, NULL);
     /*
      * END HACK
@@ -445,7 +445,7 @@
     /*
      * set the new end of file
      */
-    SetFilePointer(This->hfile, newSize.s.LowPart, NULL, FILE_BEGIN);
+    SetFilePointer(This->hfile, newSize.u.LowPart, NULL, FILE_BEGIN);
     SetEndOfFile(This->hfile);
 
     /*
@@ -473,8 +473,8 @@
     This->pbytearray = GlobalLock(This->hbytearray);
   }
 
-  This->filesize.s.LowPart = newSize.s.LowPart;
-  This->filesize.s.HighPart = newSize.s.HighPart;
+  This->filesize.u.LowPart = newSize.u.LowPart;
+  This->filesize.u.HighPart = newSize.u.HighPart;
 
   BIGBLOCKFILE_RemapAllMappedPages(This);
 }
@@ -662,8 +662,8 @@
 	DWORD numBytesToMap;
 	DWORD desired_access;
 
-	if (lowoffset + PAGE_SIZE > This->filesize.s.LowPart)
-	    numBytesToMap = This->filesize.s.LowPart - lowoffset;
+	if (lowoffset + PAGE_SIZE > This->filesize.u.LowPart)
+	    numBytesToMap = This->filesize.u.LowPart - lowoffset;
 	else
 	    numBytesToMap = PAGE_SIZE;
 
@@ -822,7 +822,7 @@
     {
 	MappedPage *next = list->next;
 
-	if (list->page_index * PAGE_SIZE > This->filesize.s.LowPart)
+	if (list->page_index * PAGE_SIZE > This->filesize.u.LowPart)
 	{
 	    TRACE("discarding %lu\n", list->page_index);
 
Index: stg_stream.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/stg_stream.c,v
retrieving revision 1.18
diff -u -r1.18 stg_stream.c
--- stg_stream.c	5 Sep 2003 23:08:33 -0000	1.18
+++ stg_stream.c	2 Jan 2004 19:11:46 -0000
@@ -106,14 +106,14 @@
     /*
      * Start the stream at the beginning.
      */
-    newStream->currentPosition.s.HighPart = 0;
-    newStream->currentPosition.s.LowPart = 0;
+    newStream->currentPosition.u.HighPart = 0;
+    newStream->currentPosition.u.LowPart = 0;
 
     /*
      * Initialize the rest of the data.
      */
-    newStream->streamSize.s.HighPart = 0;
-    newStream->streamSize.s.LowPart  = 0;
+    newStream->streamSize.u.HighPart = 0;
+    newStream->streamSize.u.LowPart  = 0;
     newStream->bigBlockChain       = 0;
     newStream->smallBlockChain     = 0;
 
@@ -294,16 +294,16 @@
     /*
      * This code supports only streams that are <32 bits in size.
      */
-    assert(This->streamSize.s.HighPart == 0);
+    assert(This->streamSize.u.HighPart == 0);
 
     if(curProperty.startingBlock == BLOCK_END_OF_CHAIN)
     {
-      assert( (This->streamSize.s.HighPart == 0) && (This->streamSize.s.LowPart == 0) );
+      assert( (This->streamSize.u.HighPart == 0) && (This->streamSize.u.LowPart == 0) );
     }
     else
     {
-      if ( (This->streamSize.s.HighPart == 0) &&
-	   (This->streamSize.s.LowPart < LIMIT_TO_USE_SMALL_BLOCK) )
+      if ( (This->streamSize.u.HighPart == 0) &&
+	   (This->streamSize.u.LowPart < LIMIT_TO_USE_SMALL_BLOCK) )
       {
 	This->smallBlockChain = SmallBlockChainStream_Construct(
 								This->parentStorage->ancestorStorage,
@@ -355,7 +355,7 @@
    * Using the known size of the stream, calculate the number of bytes
    * to read from the block chain
    */
-  bytesToReadFromBuffer = min( This->streamSize.s.LowPart - This->currentPosition.s.LowPart, cb);
+  bytesToReadFromBuffer = min( This->streamSize.u.LowPart - This->currentPosition.u.LowPart, cb);
 
   /*
    * Depending on the type of chain that was opened when the stream was constructed,
@@ -399,7 +399,7 @@
   /*
    * Advance the pointer for the number of positions read.
    */
-  This->currentPosition.s.LowPart += *pcbRead;
+  This->currentPosition.u.LowPart += *pcbRead;
 
   if(*pcbRead != cb)
   {
@@ -469,14 +469,14 @@
   }
   else
   {
-    newSize.s.HighPart = 0;
-    newSize.s.LowPart = This->currentPosition.s.LowPart + cb;
+    newSize.u.HighPart = 0;
+    newSize.u.LowPart = This->currentPosition.u.LowPart + cb;
   }
 
   /*
    * Verify if we need to grow the stream
    */
-  if (newSize.s.LowPart > This->streamSize.s.LowPart)
+  if (newSize.u.LowPart > This->streamSize.u.LowPart)
   {
     /* grow stream */
     IStream_SetSize(iface, newSize);
@@ -509,7 +509,7 @@
   /*
    * Advance the position pointer for the number of positions written.
    */
-  This->currentPosition.s.LowPart += *pcbWritten;
+  This->currentPosition.u.LowPart += *pcbWritten;
 
   return S_OK;
 }
@@ -533,7 +533,7 @@
   ULARGE_INTEGER newPosition;
 
   TRACE("(%p, %ld, %ld, %p)\n",
-	iface, dlibMove.s.LowPart, dwOrigin, plibNewPosition);
+	iface, dlibMove.u.LowPart, dwOrigin, plibNewPosition);
 
   /*
    * The caller is allowed to pass in NULL as the new position return value.
@@ -552,8 +552,8 @@
   switch (dwOrigin)
   {
     case STREAM_SEEK_SET:
-      plibNewPosition->s.HighPart = 0;
-      plibNewPosition->s.LowPart  = 0;
+      plibNewPosition->u.HighPart = 0;
+      plibNewPosition->u.LowPart  = 0;
       break;
     case STREAM_SEEK_CUR:
       *plibNewPosition = This->currentPosition;
@@ -593,12 +593,12 @@
   StgProperty    curProperty;
   BOOL         Success;
 
-  TRACE("(%p, %ld)\n", iface, libNewSize.s.LowPart);
+  TRACE("(%p, %ld)\n", iface, libNewSize.u.LowPart);
 
   /*
    * As documented.
    */
-  if (libNewSize.s.HighPart != 0)
+  if (libNewSize.u.HighPart != 0)
     return STG_E_INVALIDFUNCTION;
 
   /*
@@ -607,7 +607,7 @@
   if (!(This->grfMode & (STGM_WRITE | STGM_READWRITE)))
     return STG_E_ACCESSDENIED;
 
-  if (This->streamSize.s.LowPart == libNewSize.s.LowPart)
+  if (This->streamSize.u.LowPart == libNewSize.u.LowPart)
     return S_OK;
 
   /*
@@ -615,7 +615,7 @@
    */
   if ((This->smallBlockChain == 0) && (This->bigBlockChain == 0))
   {
-    if (libNewSize.s.LowPart < LIMIT_TO_USE_SMALL_BLOCK)
+    if (libNewSize.u.LowPart < LIMIT_TO_USE_SMALL_BLOCK)
     {
       This->smallBlockChain = SmallBlockChainStream_Construct(
                                     This->parentStorage->ancestorStorage,
@@ -640,9 +640,9 @@
    * Determine if we have to switch from small to big blocks or vice versa
    */
   if ( (This->smallBlockChain!=0) &&
-       (curProperty.size.s.LowPart < LIMIT_TO_USE_SMALL_BLOCK) )
+       (curProperty.size.u.LowPart < LIMIT_TO_USE_SMALL_BLOCK) )
   {
-    if (libNewSize.s.LowPart >= LIMIT_TO_USE_SMALL_BLOCK)
+    if (libNewSize.u.LowPart >= LIMIT_TO_USE_SMALL_BLOCK)
     {
       /*
        * Transform the small block chain into a big block chain
@@ -669,8 +669,8 @@
                                        This->ownerProperty,
                                        &curProperty);
 
-  curProperty.size.s.HighPart = libNewSize.s.HighPart;
-  curProperty.size.s.LowPart = libNewSize.s.LowPart;
+  curProperty.size.u.HighPart = libNewSize.u.HighPart;
+  curProperty.size.u.LowPart = libNewSize.u.LowPart;
 
   if (Success)
   {
@@ -705,7 +705,7 @@
   ULARGE_INTEGER totalBytesWritten;
 
   TRACE("(%p, %p, %ld, %p, %p)\n",
-	iface, pstm, cb.s.LowPart, pcbRead, pcbWritten);
+	iface, pstm, cb.u.LowPart, pcbRead, pcbWritten);
 
   /*
    * Sanity check
@@ -713,28 +713,28 @@
   if ( pstm == 0 )
     return STG_E_INVALIDPOINTER;
 
-  totalBytesRead.s.LowPart = totalBytesRead.s.HighPart = 0;
-  totalBytesWritten.s.LowPart = totalBytesWritten.s.HighPart = 0;
+  totalBytesRead.u.LowPart = totalBytesRead.u.HighPart = 0;
+  totalBytesWritten.u.LowPart = totalBytesWritten.u.HighPart = 0;
 
   /*
    * use stack to store data temporarily
    * there is surely a more performant way of doing it, for now this basic
    * implementation will do the job
    */
-  while ( cb.s.LowPart > 0 )
+  while ( cb.u.LowPart > 0 )
   {
-    if ( cb.s.LowPart >= 128 )
+    if ( cb.u.LowPart >= 128 )
       copySize = 128;
     else
-      copySize = cb.s.LowPart;
+      copySize = cb.u.LowPart;
 
     IStream_Read(iface, tmpBuffer, copySize, &bytesRead);
 
-    totalBytesRead.s.LowPart += bytesRead;
+    totalBytesRead.u.LowPart += bytesRead;
 
     IStream_Write(pstm, tmpBuffer, bytesRead, &bytesWritten);
 
-    totalBytesWritten.s.LowPart += bytesWritten;
+    totalBytesWritten.u.LowPart += bytesWritten;
 
     /*
      * Check that read & write operations were successful
@@ -746,9 +746,9 @@
     }
 
     if (bytesRead!=copySize)
-      cb.s.LowPart = 0;
+      cb.u.LowPart = 0;
     else
-      cb.s.LowPart -= bytesRead;
+      cb.u.LowPart -= bytesRead;
   }
 
   /*
@@ -756,14 +756,14 @@
    */
   if (pcbRead)
   {
-    pcbRead->s.LowPart = totalBytesRead.s.LowPart;
-    pcbRead->s.HighPart = totalBytesRead.s.HighPart;
+    pcbRead->u.LowPart = totalBytesRead.u.LowPart;
+    pcbRead->u.HighPart = totalBytesRead.u.HighPart;
   }
 
   if (pcbWritten)
   {
-    pcbWritten->s.LowPart = totalBytesWritten.s.LowPart;
-    pcbWritten->s.HighPart = totalBytesWritten.s.HighPart;
+    pcbWritten->u.LowPart = totalBytesWritten.u.LowPart;
+    pcbWritten->u.HighPart = totalBytesWritten.u.HighPart;
   }
   return hr;
 }
Index: storage32.c
===================================================================
RCS file: /home/wine/wine/dlls/ole32/storage32.c,v
retrieving revision 1.44
diff -u -r1.44 storage32.c
--- storage32.c	22 Sep 2003 19:46:13 -0000	1.44
+++ storage32.c	2 Jan 2004 19:11:50 -0000
@@ -678,7 +678,7 @@
 end:
   if (res == S_OK)
   {
-    TRACE("<-- STATSTG: pwcsName: %s, type: %ld, cbSize.Low/High: %ld/%ld, grfMode: %08lx, grfLocksSupported: %ld, grfStateBits: %08lx\n", debugstr_w(pstatstg->pwcsName), pstatstg->type, pstatstg->cbSize.s.LowPart, pstatstg->cbSize.s.HighPart, pstatstg->grfMode, pstatstg->grfLocksSupported, pstatstg->grfStateBits);
+    TRACE("<-- STATSTG: pwcsName: %s, type: %ld, cbSize.Low/High: %ld/%ld, grfMode: %08lx, grfLocksSupported: %ld, grfStateBits: %08lx\n", debugstr_w(pstatstg->pwcsName), pstatstg->type, pstatstg->cbSize.u.LowPart, pstatstg->cbSize.u.HighPart, pstatstg->grfMode, pstatstg->grfLocksSupported, pstatstg->grfStateBits);
   }
   TRACE("<-- %08lx\n", res);
   return res;
@@ -762,8 +762,8 @@
 
     renamedProperty.propertyType  = currentProperty.propertyType;
     renamedProperty.startingBlock = currentProperty.startingBlock;
-    renamedProperty.size.s.LowPart  = currentProperty.size.s.LowPart;
-    renamedProperty.size.s.HighPart = currentProperty.size.s.HighPart;
+    renamedProperty.size.u.LowPart  = currentProperty.size.u.LowPart;
+    renamedProperty.size.u.HighPart = currentProperty.size.u.HighPart;
 
     renamedProperty.previousProperty = PROPERTY_NULL;
     renamedProperty.nextProperty     = PROPERTY_NULL;
@@ -936,8 +936,8 @@
 
   newStreamProperty.propertyType  = PROPTYPE_STREAM;
   newStreamProperty.startingBlock = BLOCK_END_OF_CHAIN;
-  newStreamProperty.size.s.LowPart  = 0;
-  newStreamProperty.size.s.HighPart = 0;
+  newStreamProperty.size.u.LowPart  = 0;
+  newStreamProperty.size.u.HighPart = 0;
 
   newStreamProperty.previousProperty = PROPERTY_NULL;
   newStreamProperty.nextProperty     = PROPERTY_NULL;
@@ -1121,8 +1121,8 @@
 
   newProperty.propertyType  = PROPTYPE_STORAGE;
   newProperty.startingBlock = BLOCK_END_OF_CHAIN;
-  newProperty.size.s.LowPart  = 0;
-  newProperty.size.s.HighPart = 0;
+  newProperty.size.u.LowPart  = 0;
+  newProperty.size.u.HighPart = 0;
 
   newProperty.previousProperty = PROPERTY_NULL;
   newProperty.nextProperty     = PROPERTY_NULL;
@@ -1243,8 +1243,8 @@
     /*
      * initialize the size used by the property stream
      */
-    newSize.s.HighPart = 0;
-    newSize.s.LowPart  = storage->bigBlockSize * blockCount;
+    newSize.u.HighPart = 0;
+    newSize.u.LowPart  = storage->bigBlockSize * blockCount;
 
     /*
      * add a property block to the property chain
@@ -1872,8 +1872,8 @@
   HRESULT        hr;
   ULARGE_INTEGER size;
 
-  size.s.HighPart = 0;
-  size.s.LowPart = 0;
+  size.u.HighPart = 0;
+  size.u.LowPart = 0;
 
   hr = StorageBaseImpl_OpenStream(
          (IStorage*)parentStorage,
@@ -2280,8 +2280,8 @@
     /*
      * Add one block for the big block depot and one block for the properties
      */
-    size.s.HighPart = 0;
-    size.s.LowPart  = This->bigBlockSize * 3;
+    size.u.HighPart = 0;
+    size.u.LowPart  = This->bigBlockSize * 3;
     BIGBLOCKFILE_SetSize(This->bigBlockFile, size);
 
     /*
@@ -2348,8 +2348,8 @@
     rootProp.nextProperty     = PROPERTY_NULL;
     rootProp.dirProperty      = PROPERTY_NULL;
     rootProp.startingBlock    = BLOCK_END_OF_CHAIN;
-    rootProp.size.s.HighPart    = 0;
-    rootProp.size.s.LowPart     = 0;
+    rootProp.size.u.HighPart    = 0;
+    rootProp.size.u.LowPart     = 0;
 
     StorageImpl_WriteProperty(This, 0, &rootProp);
   }
@@ -3125,8 +3125,8 @@
   BOOL         readSuccessful;
   ULONG          bytesRead;
 
-  offsetInPropSet.s.HighPart = 0;
-  offsetInPropSet.s.LowPart  = index * PROPSET_BLOCK_SIZE;
+  offsetInPropSet.u.HighPart = 0;
+  offsetInPropSet.u.LowPart  = index * PROPSET_BLOCK_SIZE;
 
   readSuccessful = BlockChainStream_ReadAt(
                     This->rootBlockChain,
@@ -3203,9 +3203,9 @@
     StorageUtl_ReadDWord(
       currentProperty,
       OFFSET_PS_SIZE,
-      &buffer->size.s.LowPart);
+      &buffer->size.u.LowPart);
 
-    buffer->size.s.HighPart = 0;
+    buffer->size.u.HighPart = 0;
   }
 
   return readSuccessful;
@@ -3224,8 +3224,8 @@
   BOOL         writeSuccessful;
   ULONG          bytesWritten;
 
-  offsetInPropSet.s.HighPart = 0;
-  offsetInPropSet.s.LowPart  = index * PROPSET_BLOCK_SIZE;
+  offsetInPropSet.u.HighPart = 0;
+  offsetInPropSet.u.LowPart  = index * PROPSET_BLOCK_SIZE;
 
   memset(currentProperty, 0, PROPSET_BLOCK_SIZE);
 
@@ -3289,7 +3289,7 @@
   StorageUtl_WriteDWord(
     currentProperty,
       OFFSET_PS_SIZE,
-      buffer->size.s.LowPart);
+      buffer->size.u.LowPart);
 
   writeSuccessful = BlockChainStream_WriteAt(This->rootBlockChain,
                                             offsetInPropSet,
@@ -3401,8 +3401,8 @@
    * Copy the contents of the small block chain to the big block chain
    * by small block size increments.
    */
-  offset.s.LowPart = 0;
-  offset.s.HighPart = 0;
+  offset.u.LowPart = 0;
+  offset.u.HighPart = 0;
   cbTotalRead = 0;
   cbTotalWritten = 0;
 
@@ -3423,7 +3423,7 @@
                                             &cbWritten);
     cbTotalWritten += cbWritten;
 
-    offset.s.LowPart += This->smallBlockSize;
+    offset.u.LowPart += This->smallBlockSize;
 
   } while (successRead && successWrite);
   HeapFree(GetProcessHeap(),0,buffer);
@@ -3434,8 +3434,8 @@
    * Destroy the small block chain.
    */
   propertyIndex = (*ppsbChain)->ownerPropertyIndex;
-  size.s.HighPart = 0;
-  size.s.LowPart  = 0;
+  size.u.HighPart = 0;
+  size.u.LowPart  = 0;
   SmallBlockChainStream_SetSize(*ppsbChain, size);
   SmallBlockChainStream_Destroy(*ppsbChain);
   *ppsbChain = 0;
@@ -4262,8 +4262,8 @@
   void*          buffer,
   ULONG*         bytesRead)
 {
-  ULONG blockNoInSequence = offset.s.LowPart / This->parentStorage->bigBlockSize;
-  ULONG offsetInBlock     = offset.s.LowPart % This->parentStorage->bigBlockSize;
+  ULONG blockNoInSequence = offset.u.LowPart / This->parentStorage->bigBlockSize;
+  ULONG offsetInBlock     = offset.u.LowPart % This->parentStorage->bigBlockSize;
   ULONG bytesToReadInBuffer;
   ULONG blockIndex;
   BYTE* bufferWalker;
@@ -4350,8 +4350,8 @@
   const void*       buffer,
   ULONG*            bytesWritten)
 {
-  ULONG blockNoInSequence = offset.s.LowPart / This->parentStorage->bigBlockSize;
-  ULONG offsetInBlock     = offset.s.LowPart % This->parentStorage->bigBlockSize;
+  ULONG blockNoInSequence = offset.u.LowPart / This->parentStorage->bigBlockSize;
+  ULONG offsetInBlock     = offset.u.LowPart % This->parentStorage->bigBlockSize;
   ULONG bytesToWrite;
   ULONG blockIndex;
   BYTE* bufferWalker;
@@ -4446,9 +4446,9 @@
   /*
    * Figure out how many blocks are needed to contain the new size
    */
-  numBlocks = newSize.s.LowPart / This->parentStorage->bigBlockSize;
+  numBlocks = newSize.u.LowPart / This->parentStorage->bigBlockSize;
 
-  if ((newSize.s.LowPart % This->parentStorage->bigBlockSize) != 0)
+  if ((newSize.u.LowPart % This->parentStorage->bigBlockSize) != 0)
     numBlocks++;
 
   blockIndex = BlockChainStream_GetHeadOfChain(This);
@@ -4546,9 +4546,9 @@
   /*
    * Figure out how many blocks are needed to contain this stream
    */
-  newNumBlocks = newSize.s.LowPart / This->parentStorage->bigBlockSize;
+  newNumBlocks = newSize.u.LowPart / This->parentStorage->bigBlockSize;
 
-  if ((newSize.s.LowPart % This->parentStorage->bigBlockSize) != 0)
+  if ((newSize.u.LowPart % This->parentStorage->bigBlockSize) != 0)
     newNumBlocks++;
 
   /*
@@ -4620,10 +4620,10 @@
 {
   ULARGE_INTEGER size = BlockChainStream_GetSize(This);
 
-  if (newSize.s.LowPart == size.s.LowPart)
+  if (newSize.u.LowPart == size.u.LowPart)
     return TRUE;
 
-  if (newSize.s.LowPart < size.s.LowPart)
+  if (newSize.u.LowPart < size.u.LowPart)
   {
     BlockChainStream_Shrink(This, newSize);
   }
@@ -4632,7 +4632,7 @@
     ULARGE_INTEGER fileSize =
       BIGBLOCKFILE_GetSize(This->parentStorage->bigBlockFile);
 
-    ULONG diff = newSize.s.LowPart - size.s.LowPart;
+    ULONG diff = newSize.u.LowPart - size.u.LowPart;
 
     /*
      * Make sure the file stays a multiple of blocksize
@@ -4641,7 +4641,7 @@
       diff += (This->parentStorage->bigBlockSize -
                 (diff % This->parentStorage->bigBlockSize) );
 
-    fileSize.s.LowPart += diff;
+    fileSize.u.LowPart += diff;
     BIGBLOCKFILE_SetSize(This->parentStorage->bigBlockFile, fileSize);
 
     BlockChainStream_Enlarge(This, newSize);
@@ -4681,9 +4681,9 @@
      * size of them
      */
     ULARGE_INTEGER result;
-    result.s.HighPart = 0;
+    result.u.HighPart = 0;
 
-    result.s.LowPart  =
+    result.u.LowPart  =
       BlockChainStream_GetCount(This) *
       This->parentStorage->bigBlockSize;
 
@@ -4764,8 +4764,8 @@
 
   *nextBlockInChain = BLOCK_END_OF_CHAIN;
 
-  offsetOfBlockInDepot.s.HighPart = 0;
-  offsetOfBlockInDepot.s.LowPart  = blockIndex * sizeof(ULONG);
+  offsetOfBlockInDepot.u.HighPart = 0;
+  offsetOfBlockInDepot.u.LowPart  = blockIndex * sizeof(ULONG);
 
   /*
    * Read those bytes in the buffer from the small block file.
@@ -4803,8 +4803,8 @@
   DWORD  buffer;
   ULONG  bytesWritten;
 
-  offsetOfBlockInDepot.s.HighPart = 0;
-  offsetOfBlockInDepot.s.LowPart  = blockIndex * sizeof(ULONG);
+  offsetOfBlockInDepot.u.HighPart = 0;
+  offsetOfBlockInDepot.u.LowPart  = blockIndex * sizeof(ULONG);
 
   StorageUtl_WriteDWord(&buffer, 0, nextBlock);
 
@@ -4849,14 +4849,14 @@
   BOOL success = TRUE;
   ULONG smallBlocksPerBigBlock;
 
-  offsetOfBlockInDepot.s.HighPart = 0;
+  offsetOfBlockInDepot.u.HighPart = 0;
 
   /*
    * Scan the small block depot for a free block
    */
   while (nextBlockIndex != BLOCK_UNUSED)
   {
-    offsetOfBlockInDepot.s.LowPart = blockIndex * sizeof(ULONG);
+    offsetOfBlockInDepot.u.LowPart = blockIndex * sizeof(ULONG);
 
     success = BlockChainStream_ReadAt(
                 This->parentStorage->smallBlockDepotChain,
@@ -4943,8 +4943,8 @@
           &rootProp);
 
         rootProp.startingBlock = sbStartIndex;
-        rootProp.size.s.HighPart = 0;
-        rootProp.size.s.LowPart  = This->parentStorage->bigBlockSize;
+        rootProp.size.u.HighPart = 0;
+        rootProp.size.u.LowPart  = This->parentStorage->bigBlockSize;
 
         StorageImpl_WriteProperty(
           This->parentStorage,
@@ -4970,10 +4970,10 @@
       This->parentStorage->rootPropertySetIndex,
       &rootProp);
 
-    if (rootProp.size.s.LowPart <
+    if (rootProp.size.u.LowPart <
        (blocksRequired * This->parentStorage->bigBlockSize))
     {
-      rootProp.size.s.LowPart += This->parentStorage->bigBlockSize;
+      rootProp.size.u.LowPart += This->parentStorage->bigBlockSize;
 
       BlockChainStream_SetSize(
         This->parentStorage->smallBlockRootChain,
@@ -5005,9 +5005,9 @@
 {
   ULARGE_INTEGER offsetInBigBlockFile;
   ULONG blockNoInSequence =
-    offset.s.LowPart / This->parentStorage->smallBlockSize;
+    offset.u.LowPart / This->parentStorage->smallBlockSize;
 
-  ULONG offsetInBlock = offset.s.LowPart % This->parentStorage->smallBlockSize;
+  ULONG offsetInBlock = offset.u.LowPart % This->parentStorage->smallBlockSize;
   ULONG bytesToReadInBuffer;
   ULONG blockIndex;
   ULONG bytesReadFromBigBlockFile;
@@ -5016,7 +5016,7 @@
   /*
    * This should never happen on a small block file.
    */
-  assert(offset.s.HighPart==0);
+  assert(offset.u.HighPart==0);
 
   /*
    * Find the first block in the stream that contains part of the buffer.
@@ -5048,11 +5048,11 @@
     /*
      * Calculate the offset of the small block in the small block file.
      */
-    offsetInBigBlockFile.s.HighPart  = 0;
-    offsetInBigBlockFile.s.LowPart   =
+    offsetInBigBlockFile.u.HighPart  = 0;
+    offsetInBigBlockFile.u.LowPart   =
       blockIndex * This->parentStorage->smallBlockSize;
 
-    offsetInBigBlockFile.s.LowPart  += offsetInBlock;
+    offsetInBigBlockFile.u.LowPart  += offsetInBlock;
 
     /*
      * Read those bytes in the buffer from the small block file.
@@ -5095,9 +5095,9 @@
 {
   ULARGE_INTEGER offsetInBigBlockFile;
   ULONG blockNoInSequence =
-    offset.s.LowPart / This->parentStorage->smallBlockSize;
+    offset.u.LowPart / This->parentStorage->smallBlockSize;
 
-  ULONG offsetInBlock = offset.s.LowPart % This->parentStorage->smallBlockSize;
+  ULONG offsetInBlock = offset.u.LowPart % This->parentStorage->smallBlockSize;
   ULONG bytesToWriteInBuffer;
   ULONG blockIndex;
   ULONG bytesWrittenFromBigBlockFile;
@@ -5106,7 +5106,7 @@
   /*
    * This should never happen on a small block file.
    */
-  assert(offset.s.HighPart==0);
+  assert(offset.u.HighPart==0);
 
   /*
    * Find the first block in the stream that contains part of the buffer.
@@ -5139,11 +5139,11 @@
     /*
      * Calculate the offset of the small block in the small block file.
      */
-    offsetInBigBlockFile.s.HighPart  = 0;
-    offsetInBigBlockFile.s.LowPart   =
+    offsetInBigBlockFile.u.HighPart  = 0;
+    offsetInBigBlockFile.u.LowPart   =
       blockIndex * This->parentStorage->smallBlockSize;
 
-    offsetInBigBlockFile.s.LowPart  += offsetInBlock;
+    offsetInBigBlockFile.u.LowPart  += offsetInBlock;
 
     /*
      * Write those bytes in the buffer to the small block file.
@@ -5184,9 +5184,9 @@
   ULONG numBlocks;
   ULONG count = 0;
 
-  numBlocks = newSize.s.LowPart / This->parentStorage->smallBlockSize;
+  numBlocks = newSize.u.LowPart / This->parentStorage->smallBlockSize;
 
-  if ((newSize.s.LowPart % This->parentStorage->smallBlockSize) != 0)
+  if ((newSize.u.LowPart % This->parentStorage->smallBlockSize) != 0)
     numBlocks++;
 
   blockIndex = SmallBlockChainStream_GetHeadOfChain(This);
@@ -5297,9 +5297,9 @@
   /*
    * Figure out how many blocks are needed to contain this stream
    */
-  newNumBlocks = newSize.s.LowPart / This->parentStorage->smallBlockSize;
+  newNumBlocks = newSize.u.LowPart / This->parentStorage->smallBlockSize;
 
-  if ((newSize.s.LowPart % This->parentStorage->smallBlockSize) != 0)
+  if ((newSize.u.LowPart % This->parentStorage->smallBlockSize) != 0)
     newNumBlocks++;
 
   /*
@@ -5373,10 +5373,10 @@
 {
   ULARGE_INTEGER size = SmallBlockChainStream_GetSize(This);
 
-  if (newSize.s.LowPart == size.s.LowPart)
+  if (newSize.u.LowPart == size.u.LowPart)
     return TRUE;
 
-  if (newSize.s.LowPart < size.s.LowPart)
+  if (newSize.u.LowPart < size.u.LowPart)
   {
     SmallBlockChainStream_Shrink(This, newSize);
   }
@@ -5803,7 +5803,7 @@
  *
  *
  */
-HRESULT WINAPI StgSetTimes(OLECHAR *str, FILETIME *a, FILETIME *b, FILETIME *c )
+HRESULT WINAPI StgSetTimes(OLECHAR const *str, FILETIME const *a, FILETIME const *b, FILETIME const *c )
 {
   FIXME("(%s, %p, %p, %p),stub!\n", debugstr_w(str), a, b, c);
   return S_OK;
@@ -5819,8 +5819,8 @@
   BYTE sig[8];
   ULARGE_INTEGER offset;
 
-  offset.s.HighPart = 0;
-  offset.s.LowPart  = 0;
+  offset.u.HighPart = 0;
+  offset.u.LowPart  = 0;
 
   ILockBytes_ReadAt(plkbyt, offset, sig, sizeof(sig), NULL);
 
@@ -7086,15 +7086,15 @@
     {
 
         /*Get the OleType from the CompObj Stream */
-        iSeekPos.s.LowPart = sizeof(CompObj.byUnknown1) + sizeof(CompObj.clsid);
-        iSeekPos.s.HighPart = 0;
+        iSeekPos.u.LowPart = sizeof(CompObj.byUnknown1) + sizeof(CompObj.clsid);
+        iSeekPos.u.HighPart = 0;
 
         IStream_Seek(pStream, iSeekPos, STREAM_SEEK_SET, NULL);
         IStream_Read(pStream, &CompObj.dwCLSIDNameLength, sizeof(CompObj.dwCLSIDNameLength), NULL);
-        iSeekPos.s.LowPart = CompObj.dwCLSIDNameLength;
+        iSeekPos.u.LowPart = CompObj.dwCLSIDNameLength;
         IStream_Seek(pStream, iSeekPos, STREAM_SEEK_CUR , NULL);
         IStream_Read(pStream, &CompObj.dwOleTypeNameLength, sizeof(CompObj.dwOleTypeNameLength), NULL);
-        iSeekPos.s.LowPart = CompObj.dwOleTypeNameLength;
+        iSeekPos.u.LowPart = CompObj.dwOleTypeNameLength;
         IStream_Seek(pStream, iSeekPos, STREAM_SEEK_CUR , NULL);
 
         IStream_Read(pStream, dwSize, sizeof(*dwSize), NULL);
@@ -7233,8 +7233,8 @@
         pOleStreamData[1].dwOleTypeNameLength = strlen(strMetafilePictName) +1;
         strcpy(pOleStreamData[1].strOleTypeName, strMetafilePictName);
 
-        iSeekPos.s.HighPart = 0;
-        iSeekPos.s.LowPart = sizeof(olePress.byUnknown1);
+        iSeekPos.u.HighPart = 0;
+        iSeekPos.u.LowPart = sizeof(olePress.byUnknown1);
 
         /* Get Presentation Data */
         IStream_Seek(pStream, iSeekPos, STREAM_SEEK_SET, NULL);
@@ -7435,8 +7435,8 @@
 /***********************************************************************
  *		GetConvertStg (OLE32.@)
  */
-HRESULT WINAPI GetConvertStg(LPGUID guid) {
-    FIXME("(%s), unimplemented stub!\n",debugstr_guid(guid));
+HRESULT WINAPI GetConvertStg(IStorage *stg) {
+    FIXME("unimplemented stub!\n");
     return E_FAIL;
 }
 
