/*
 * COPYRIGHT:       See COPYING in the top level directory
 * PROJECT:         ReactOS system libraries
 * FILE:            lib/kernel32/misc/except.c
 * PURPOSE:         Exception functions
 * PROGRAMMER:      Ariadne ( ariadne@xs4all.nl)
		    modified from WINE [ Onno Hovers, (onno@stack.urc.tue.nl) ]
 * UPDATE HISTORY:
 *                  Created 01/11/98
 */

#include <windows.h>
#include <ddk/ntddk.h>


typedef LONG (STDCALL *LPTOP_LEVEL_EXCEPTION_FILTER)(
	struct _EXCEPTION_POINTERS *ExceptionInfo
 	);

UINT GlobalErrMode;
LPTOP_LEVEL_EXCEPTION_FILTER GlobalTopLevelExceptionFilter;

UINT GetErrorMode(void);

//FIXME Please remove comments in funcs.h
LPTOP_LEVEL_EXCEPTION_FILTER
STDCALL
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );


// these are in various flavors


typedef enum _EXCEPTION_DISPOSITION 
{
	ExceptionContinueExecution,
	ExceptionContinueSearch,
	ExceptionNestedException,
	ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;
                                            

#define	DISPOSITION_DISMISS			0
#define DISPOSITION_CONTINUE_SEARCH		1
#define DISPOSITION_NESTED_EXCEPTION		2
#define	DISPOSITION_COLLIDED_UNWIND		3

// following values can be returned by exception filters
// in a try{} except() block.

//#define EXCEPTION_EXECUTE_HANDLER        1
//#define EXCEPTION_CONTINUE_SEARCH        0
//#define EXCEPTION_CONTINUE_EXECUTION    -1

// OS/2 filter return codes
#define	FILTER_ACCEPT					 1
#define	FILTER_DISMISS					-1
#define FILTER_CONTINUE_SEARCH			 0


#define	TRYLEVEL_NONE					-1
#define	TRYLEVEL_INVALID				-2

//callback interface codes (mimimal required set)

#define	CB_GET_MAX_CODE					0
#define	CB_DO_LOCAL_UNWIND				1
#define	CB_GET_FRAME_EBP				2
#define	CB_GET_SCOPE_INDEX				3
#define	CB_GET_SCOPE_DATA				4
#define	MAX_CALLBACK_CODE				4


#define EH_NONCONTINUABLE				1          
#define EH_UNWINDING					2          
#define EH_EXIT_UNWIND					4          
#define EH_STACK_INVALID				8          
#define EH_NESTED_CALL					16

//#define FACILITY_RPC_RUNTIME             		2
//#define FACILITY_RPC_STUBS               		3
//#define FACILITY_IO_ERROR_CODE           		4

//#define SEVERITY_CODE_SUCCESS				0
//#define SEVERITY_CODE_INFORMATIONAL			1
//#define SEVERITY_CODE_WARNING				2
//#define SEVERITY_CODE_ERROR 				3


#define XCPT_FATAL_EXCEPTION    		(0xC0000000)
#define XCPT_SEVERITY_CODE      		(0xC0000000)
#define XCPT_CUSTOMER_CODE      		(0x20000000)
#define XCPT_FACILITY_CODE      		(0x1FFF0000)
#define XCPT_EXCEPTION_CODE     		(0x0000FFFF)


// this is the definition of NTSTATUS

// definition of NTSTATUS

typedef struct _NTSTATUSDEF
{
	USHORT	Code;
	USHORT  Facility	:12;
	UCHAR   Reserved 	: 1;
	UCHAR	CstCodeFlag 	: 1;
	UCHAR	Severity 	: 2;
} NTSTATUSDEF;

//  Violation flags in ExceptionInfo 

#define XCPT_UNKNOWN_ACCESS     	0x00000000      
#define XCPT_READ_ACCESS        	0x00000001      
#define XCPT_WRITE_ACCESS       	0x00000002      
#define XCPT_EXECUTE_ACCESS     	0x00000004      
#define XCPT_SPACE_ACCESS       	0x00000008      // address space access violation
#define XCPT_LIMIT_ACCESS       	0x00000010      // out of bounds
#define XCPT_DATA_UNKNOWN       	0xFFFFFFFF


//  some status values with corresponding ExceptionInfo values 

//#define STATUS_GUARD_PAGE_VIOLATION       0x80000001
      // ExceptionInfo[ 0 ] - Access Code: XCPT_READ_ACCESS | XCPT_WRITE_ACCESS 
      // ExceptionInfo[ 1 ] - FaultAddr 


//#define STATUS_DATATYPE_MISALIGNMENT      0x80000002
	// OS/2 XCPT is at 0xC000009E
    // ExceptionInfo[ 0 ] - Access Code: XCPT_READ_ACCESS | XCPT_WRITE_ACCESS 
    // ExceptionInfo[ 1 ] - Alignment 
    // ExceptionInfo[ 2 ] - FaultAddr 


//#define STATUS_ACCESS_VIOLATION           0xC0000005
      // ExceptionInfo[ 0 ] - Access Code:   XCPT_READ_ACCESS | XCPT_WRITE_ACCESS
      // ExceptionInfo[ 1 ] - FaultAddr 
  

//#define STATUS_IN_PAGE_ERROR              0xC0000006
      // ExceptionInfo[ 0 ] - FaultAddr 

//#define STATUS_NONCONTINUABLE_EXCEPTION   0xC0000025
//#define STATUS_INVALID_DISPOSITION        0xC0000026


// Exceptions generated by the exception handler

#define STATUS_UNWIND                     0xC0000027
#define STATUS_BAD_STACK                  0xC0000028
#define STATUS_INVALID_UNWIND_TARGET      0xC0000029


typedef struct _EXCEPTION_REGISTRATION;

typedef EXCEPTION_DISPOSITION
(STDCALL *ExceptionHandlerType)(
	struct _EXCEPTION_RECORD *ExceptionRecord,
	struct _EXCEPTION_REGISTRATION  *EstablisherFrame,
	struct _CONTEXT *Context,
	struct _EXCEPTION_RECORD *DispatcherContext
	);




typedef struct _SCOPE_TABLE {
	DWORD prevTryLevel;
	LPTOP_LEVEL_EXCEPTION_FILTER lpfnFilter;
	ExceptionHandlerType lpfnHandler;
} SCOPE_TABLE , *PSCOPE_TABLE;

typedef struct _EXCEPTION_REGISTRATION {
	struct _EXCEPTION_REGISTRATION *Prev;
	ExceptionHandlerType Handler;
	PSCOPE_TABLE ScopeTable;
	unsigned int TryLevel;
	unsigned int _ebp;
	PEXCEPTION_POINTERS *Pointers;
} EXCEPTION_REGISTRATION, *PEXCEPTION_REGISTRATION;

#define END_OF_CHAIN        ((PEXCEPTION_REGISTRATION) -1)











EXCEPTION_DISPOSITION
CDECL
ExceptionHandler(
	struct _EXCEPTION_RECORD *ExceptionRecord,
	struct _EXCEPTION_REGISTRATION *RegistrationFrame,
	CONTEXT *Context,
	struct _EXCEPTION_RECORD *DispatcherContext
	);

void KiUserExceptionDispatcher(
	struct _EXCEPTION_RECORD *ExceptionRecord,
	CONTEXT *Context);

NTSTATUS RtlDispatchException(
	struct _EXCEPTION_RECORD *ExceptionRecord,
	CONTEXT *Context);

struct _EXCEPTION_REGISTRATION *RtlpGetRegistrationHead(VOID);

void RtlpCaptureContext(CONTEXT *Context);
void RtlpGetStackLimits(void *StackBase, void *StackLimit);
void RtlpUnlinkHandler(struct _EXCEPTION_REGISTRATION *__head);
void RtlpLinkHandler(struct _EXCEPTION_REGISTRATION *__head);
void RtlUnwind(struct _EXCEPTION_REGISTRATION *RegistratonFrame,
		VOID *ReturnAddress, // Unused
		struct _EXCEPTION_RECORD *ExceptionRecord,
		DWORD _eax);

void RtlRaiseException(struct _EXCEPTION_RECORD *ExceptionRecord);





UINT GetErrorMode(void)
{
	return GlobalErrMode;
}

UINT 
STDCALL
SetErrorMode(  UINT uMode  )
{
	UINT OldErrMode = GetErrorMode();
	GlobalErrMode = uMode;
	return OldErrMode;
}

LPTOP_LEVEL_EXCEPTION_FILTER
STDCALL
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    )
{
    LPTOP_LEVEL_EXCEPTION_FILTER OldTopLevelExceptionFilter =
					 GlobalTopLevelExceptionFilter;
    lpTopLevelExceptionFilter = GlobalTopLevelExceptionFilter;
    return OldTopLevelExceptionFilter;
}








LONG 
STDCALL
ExceptionFilter (
	PEXCEPTION_POINTERS ExceptionInfo
	)
{
	return TRUE;
}

EXCEPTION_DISPOSITION
CDECL
ExceptionHandler(
	struct _EXCEPTION_RECORD *ExceptionRecord,
	struct _EXCEPTION_REGISTRATION *RegistrationFrame,
	CONTEXT *Context,
	struct _EXCEPTION_RECORD *DispatcherContext
	)
{
	int FilterRet;
	unsigned int TryLevel;
	EXCEPTION_POINTERS ExceptionPointers;
	SCOPE_TABLE *ScopeTable;
	unsigned int _ebp;


//	__asm { cld };

	if ( ExceptionRecord->ExceptionFlags != EH_UNWINDING &&
		 ExceptionRecord->ExceptionFlags != EH_EXIT_UNWIND ) 
	{
		ExceptionPointers.ExceptionRecord= ExceptionRecord;
		ExceptionPointers.ContextRecord = Context;

		//

		TryLevel = RegistrationFrame->TryLevel;

		ScopeTable = RegistrationFrame->ScopeTable;

		if ( RegistrationFrame->TryLevel != TRYLEVEL_NONE )
		{
			if ( RegistrationFrame->ScopeTable[TryLevel].lpfnFilter != NULL)
			{
				_ebp = RegistrationFrame->_ebp;
				//__asm { push ebp 
				//	  mov ebp, _ebp
				//}
				FilterRet = ScopeTable->lpfnFilter(NULL);
				//__asm { pop ebp }

				if ( FilterRet < 0 )
					return ExceptionContinueExecution;

				if ( FilterRet == EXCEPTION_EXECUTE_HANDLER )
				{
					ScopeTable = RegistrationFrame->ScopeTable;
					RtlUnwind(RegistrationFrame,NULL,ExceptionRecord,0);
					//__asm { mov ebp, _ebp }
					// local unwind
					// nlg

					RegistrationFrame->TryLevel = ScopeTable->prevTryLevel;
					RegistrationFrame->ScopeTable[TryLevel].lpfnHandler(ExceptionRecord,RegistrationFrame,Context, DispatcherContext);
					NtContinue(Context,PASSIVE_LEVEL);
					//return;

				}
				else {
					ScopeTable = RegistrationFrame->ScopeTable;
					TryLevel = ScopeTable->prevTryLevel;
					// search for handler
					return DISPOSITION_CONTINUE_SEARCH;
				}
				
			}
		} else { // TRYLEVEL_NONE
			return DISPOSITION_CONTINUE_SEARCH;
		}
	} else { // EXCEPTION_UNWINDING or EXCEPTION_EXIT_UNWIND
			//
			return DISPOSITION_CONTINUE_SEARCH;
	}
	return DISPOSITION_CONTINUE_SEARCH;
}





LONG 
STDCALL
UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
{
	char message[80];
	DWORD	dbgRet;
	HANDLE DebugPort;
	NTSTATUS errCode;

	DWORD DebuggerPresent;


	if(ExceptionInfo->ExceptionRecord->ExceptionCode == STATUS_ACCESS_VIOLATION) {
		// might check read only resource
		// Is there a debugger running ?
		errCode = NtQueryInformationProcess(NtCurrentProcess(),ProcessDebugPort,&DebugPort,sizeof(HANDLE),NULL);
  		if ( !NT_SUCCESS(errCode) ) {
			SetLastError(RtlNtStatusToDosError(errCode));
			return EXCEPTION_EXECUTE_HANDLER;
		}
		if ( DebugPort ) {
			//return EXCEPTION_CONTINUE_SEARCH;
		}   
    	if(GlobalTopLevelExceptionFilter != NULL) {
		dbgRet = GlobalTopLevelExceptionFilter(ExceptionInfo);
        	if(dbgRet == EXCEPTION_EXECUTE_HANDLER) 
        		return EXCEPTION_EXECUTE_HANDLER;
        	else if(dbgRet == EXCEPTION_CONTINUE_EXECUTION) 
         		return EXCEPTION_CONTINUE_EXECUTION;
		}

	}
	
	//if ( GetErrorMode() & SEM_NOGPFAULTERRORBOX == SEM_NOGPFAULTERRORBOX ) {
		// produce a stack trace or pop a message
		//sprintf( message, "Unhandled exception 0x%08lx at address 0x%08lx.",
             	//	ExceptionInfo->ExceptionRecord->ExceptionCode,
             	//	(DWORD)ExceptionInfo->ExceptionRecord->ExceptionAddress );
		//MessageBoxA( 0, message, "Error", MB_OK | MB_ICONHAND );
	
	//}
	// Returning EXCEPTION_EXECUTE_HANDLER means that the code in 
	// the __execept block will be executed. Normally this will end up in a
	// Terminate process.

	return EXCEPTION_EXECUTE_HANDLER;
	
}


void KiUserExceptionDispatcher(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT Context)
{
	NTSTATUS errCode;

	if ( RtlDispatchException(ExceptionRecord,Context) ) 
		errCode = NtContinue(Context,PASSIVE_LEVEL);
	else
		errCode = NtRaiseException(ExceptionRecord,Context,(BOOLEAN)FALSE);
	
	
}



NTSTATUS RtlDispatchException(PEXCEPTION_RECORD ExceptionRecord, PCONTEXT Context)
{
	NTSTATUS errCode;
	ULONG StackBase, StackLimit;
	PEXCEPTION_REGISTRATION RegistrationFrame;
	EXCEPTION_RECORD DispatcherContext;
	EXCEPTION_RECORD FatalExceptionRecord;

	//RtlpGetStackLimits(&StackBase,&StackTop);
	RegistrationFrame = RtlpGetRegistrationHead();
	
	while( RegistrationFrame != END_OF_CHAIN ) {

	//FIXME Check the stack
		RtlpGetStackLimits(&StackBase, &StackLimit);

		errCode = RegistrationFrame->Handler( 
				ExceptionRecord,
                        	RegistrationFrame,
                        	Context, 
				&DispatcherContext);

		//errCode = RtlpExecuteHandlerForException(ExceptionRecord, RegistrationFrame,
		//		Context, &DispatcherContext);

		if ( RegistrationFrame == NULL )
			ExceptionRecord->ExceptionFlags &= ~EH_NESTED_CALL;
	
		switch( errCode ) {
		  case DISPOSITION_DISMISS:
			if ( ExceptionRecord->ExceptionFlags & EH_NONCONTINUABLE ) {
				FatalExceptionRecord.ExceptionRecord = ExceptionRecord;
				FatalExceptionRecord.ExceptionCode = STATUS_NONCONTINUABLE_EXCEPTION;
				FatalExceptionRecord.ExceptionFlags = EH_NONCONTINUABLE;
				FatalExceptionRecord.NumberParameters = 0;
				RtlRaiseException(&FatalExceptionRecord);
			}
			else
				return DISPOSITION_CONTINUE_SEARCH;
			break;
		  case DISPOSITION_CONTINUE_SEARCH:
			break;
		  case DISPOSITION_NESTED_EXCEPTION:
			ExceptionRecord->ExceptionFlags |= EH_EXIT_UNWIND;
			break;
	
	  	  default:
			FatalExceptionRecord.ExceptionRecord = ExceptionRecord;
			FatalExceptionRecord.ExceptionCode = STATUS_NONCONTINUABLE_EXCEPTION;
			FatalExceptionRecord.ExceptionFlags = EH_NONCONTINUABLE;
			FatalExceptionRecord.NumberParameters = 0;
			RtlRaiseException(&FatalExceptionRecord);
			break;
		}

		RegistrationFrame = RegistrationFrame->Prev;
	}
	return DISPOSITION_DISMISS;
	
	
}

PEXCEPTION_REGISTRATION RtlpGetRegistrationHead(VOID)
{
	PEXCEPTION_REGISTRATION __head;
/*
	__asm  {
		mov eax, fs:[0]
		mov __head,eax
	}
*/
	return __head;
}



void RtlUnwind(PEXCEPTION_REGISTRATION RegistrationFrame,
		PVOID ReturnAddress, // Unused
		PEXCEPTION_RECORD ExceptionRecord,
		DWORD _eax)
{
	NTSTATUS errCode, retval;
	DWORD StackBase;
	DWORD StackTop;
	CONTEXT Context;
	PEXCEPTION_REGISTRATION TraversingFrame;
	EXCEPTION_RECORD TraversingRecord;
	EXCEPTION_RECORD DispatcherContext;
	

	 /* build an exception record, if we do not have one */
	if(ExceptionRecord != NULL)
	{
		ExceptionRecord->ExceptionCode    = (DWORD)STATUS_UNWIND; //STATUS_INVALID_DISPOSITION;
		ExceptionRecord->ExceptionFlags   = 0;
		ExceptionRecord->ExceptionRecord  = NULL;
 		//ExceptionRecord->ExceptionAddress = (LPVOID)pcontext->Eip; 
		ExceptionRecord->NumberParameters = 0;
		ExceptionRecord->ExceptionInformation[0] =0;
	
   	
		if ( RegistrationFrame != NULL ) 
			ExceptionRecord->ExceptionFlags |= EH_UNWINDING;
		else
			ExceptionRecord->ExceptionFlags |= 
				(EH_UNWINDING|EH_EXIT_UNWIND);
	}	
	Context.ContextFlags |= 
		(CONTEXT_i386|CONTEXT_FULL);
	RtlpCaptureContext(&Context);
	Context.Esp += 0x10;
	Context.Eax = _eax;

	TraversingFrame = RtlpGetRegistrationHead();
	
	while( ( TraversingFrame != NULL ) && ( TraversingFrame != END_OF_CHAIN ) && ( TraversingFrame != RegistrationFrame ) )
 	{
			    
       		errCode = TraversingFrame->Handler( 
						ExceptionRecord,
                        TraversingFrame,
                        &Context, 
						&DispatcherContext);
		if ( (retval == ExceptionCollidedUnwind) && (TraversingFrame != (LPVOID)&DispatcherContext) )
           		TraversingFrame = (LPVOID)&DispatcherContext;
       	else if ((TraversingFrame != RegistrationFrame) && (TraversingFrame != TraversingFrame->Prev) ) {
			RtlpUnlinkHandler(TraversingFrame);
			TraversingFrame = TraversingFrame->Prev;
		}
       	else
          		break;  
	}	
}


void RtlpUnlinkHandler(PEXCEPTION_REGISTRATION __head)
{
	PEXCEPTION_REGISTRATION theHead;
	PEXCEPTION_REGISTRATION theLast;
	theHead = RtlpGetRegistrationHead();
	
/*
	if ( __head == NULL )
		return;

	if ( theHead == __head ) {
		theHead = theHead->Prev;
		__asm {
			mov eax, theHead
			mov fs:[0], eax
		}
		
		return;		
	} 
	else {
		do { 
			theLast = theHead;
			theHead = theHead->Prev;
			if ( theHead == __head ) {
				theLast->Prev = theHead->Prev;
			}
		} while ( theHead != NULL && theHead != END_OF_CHAIN );
	}

*/	
	return;
}

void RtlpLinkHandler(PEXCEPTION_REGISTRATION __head)
{
	PEXCEPTION_REGISTRATION theHead;
	if (__head == NULL)
		return;

	theHead = RtlpGetRegistrationHead();
	__head->Prev = theHead;
/*
	__asm {
		mov eax, __head
		mov fs:[0], eax
	}
*/	
}


void RtlpCaptureContext(PCONTEXT Context)
{
	return;
}

void RtlpGetStackLimits(void *StackBase, void *StackLimit)
{
/*
	__asm{ mov eax, fs:[4] 
		   mov StackBase, eax }	
	__asm{ mov eax, fs:[5] 
		   mov StackLimit, eax }	
*/
	return;

}

void RtlRaiseException(struct _EXCEPTION_RECORD *ExceptionRecord)
{
	return;
}





