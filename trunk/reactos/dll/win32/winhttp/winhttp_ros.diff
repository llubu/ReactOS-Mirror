--- wine-1.5.4/dlls/winhttp/net.c	2012-06-20 14:30:41 +0200
+++ dll/win32/winhttp/net.c	2012-06-21 18:00:53 +0200
@@ -160,6 +160,7 @@ static void ssl_lock_callback(int mode,
 #endif
 
 /* translate a unix error code into a winsock error code */
+#ifndef __REACTOS__
 static int sock_get_error( int err )
 {
 #if !defined(__MINGW32__) && !defined (_MSC_VER)
@@ -225,6 +226,15 @@ static int sock_get_error( int err )
 #endif
     return err;
 }
+#else
+#define sock_get_error(x) WSAGetLastError()
+
+static inline int unix_ioctl(int filedes, long request, void *arg)
+{
+    return ioctlsocket(filedes, request, arg);
+}
+#define ioctlsocket unix_ioctl
+#endif
 
 #ifdef SONAME_LIBSSL
 static PCCERT_CONTEXT X509_to_cert_context(X509 *cert)
@@ -648,11 +658,17 @@ BOOL netconn_connect( netconn_t *conn, c
         res = sock_get_error( errno );
         if (res == WSAEWOULDBLOCK || res == WSAEINPROGRESS)
         {
-            struct pollfd pfd;
+            // ReactOS: use select instead of poll
+            fd_set outfd;
+            struct timeval tv;
 
-            pfd.fd = conn->socket;
-            pfd.events = POLLOUT;
-            if (poll( &pfd, 1, timeout ) > 0)
+            FD_ZERO(&outfd);
+            FD_SET(conn->socket, &outfd);
+
+            tv.tv_sec = 0;
+            tv.tv_usec = timeout * 1000;
+
+            if (select( 0, NULL, &outfd, NULL, &tv ) > 0)
                 ret = TRUE;
             else
                 res = sock_get_error( errno );
@@ -848,7 +864,8 @@ BOOL netconn_query_data_available( netco
 
 BOOL netconn_get_next_line( netconn_t *conn, char *buffer, DWORD *buflen )
 {
-    struct pollfd pfd;
+    // ReactOS: use select instead of poll
+    fd_set infd;
     BOOL ret = FALSE;
     DWORD recvd = 0;
 
@@ -884,19 +901,21 @@ BOOL netconn_get_next_line( netconn_t *c
 #endif
     }
 
-    pfd.fd = conn->socket;
-    pfd.events = POLLIN;
+    FD_ZERO(&infd);
+    FD_SET(conn->socket, &infd);
+
     while (recvd < *buflen)
     {
-        int timeout, res;
-        struct timeval tv;
+        int res;
+        struct timeval tv, *ptv;
         socklen_t len = sizeof(tv);
 
         if ((res = getsockopt( conn->socket, SOL_SOCKET, SO_RCVTIMEO, (void*)&tv, &len ) != -1))
-            timeout = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+            ptv = &tv;
         else
-            timeout = -1;
-        if (poll( &pfd, 1, timeout ) > 0)
+            ptv = NULL;
+
+        if (select( 0, &infd, NULL, NULL, ptv ) > 0)
         {
             if ((res = recv( conn->socket, &buffer[recvd], 1, 0 )) <= 0)
             {
--- wine-1.5.4/dlls/winhttp/request.c	2012-06-20 14:30:41 +0200
+++ dll/win32/winhttp/request.c	2012-06-21 17:32:47 +0200
@@ -38,6 +38,8 @@
 
 #include "winhttp_private.h"
 
+#include "inet_ntop.c"
+
 WINE_DEFAULT_DEBUG_CHANNEL(winhttp);
 
 static const WCHAR attr_accept[] = {'A','c','c','e','p','t',0};
--- wine-1.5.4/dlls/winhttp/rsrc.rc	2012-06-20 14:30:41 +0200
+++ dll/win32/winhttp/rsrc.rc	2012-07-14 15:25:28 +0200
@@ -16,6 +16,12 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+/* @makedep: winhttp_tlb.tlb */
+1 TYPELIB winhttp_tlb.tlb
+
+/* @makedep: winhttp_tlb.rgs */
+1 WINE_REGISTRY winhttp_tlb.rgs
+
 /* @makedep: pac.js */
 pac.js 40 "pac.js"
 
--- wine-1.5.4/dlls/winhttp/session.c	2012-07-13 15:34:57 +0200
+++ dll/win32/winhttp/session.c	2012-06-23 17:51:47 +0200
@@ -95,6 +95,9 @@ static void session_destroy( object_head
     heap_free( session->proxy_username );
     heap_free( session->proxy_password );
     heap_free( session );
+#ifdef __REACTOS__
+    WSACleanup();
+#endif
 }
 
 static BOOL session_query_option( object_header_t *hdr, DWORD option, LPVOID buffer, LPDWORD buflen )
@@ -203,6 +206,11 @@ HINTERNET WINAPI WinHttpOpen( LPCWSTR ag
 {
     session_t *session;
     HINTERNET handle = NULL;
+#ifdef __REACTOS__
+    WSADATA wsaData;
+    int error = WSAStartup(MAKEWORD(2, 2), &wsaData);
+    if (error) ERR("WSAStartup failed: %d\n", error);
+#endif
 
     TRACE("%s, %u, %s, %s, 0x%08x\n", debugstr_w(agent), access, debugstr_w(proxy), debugstr_w(bypass), flags);
 
