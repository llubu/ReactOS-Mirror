Index: commctrl.c
===================================================================
--- commctrl.c	(revision 55577)
+++ commctrl.c	(working copy)
@@ -1593,12 +1593,114 @@
  *
  * Draw text with shadow.
  */
-int WINAPI DrawShadowText(HDC hdc, LPCWSTR pszText, UINT cch, RECT *rect, DWORD dwFlags,
+int WINAPI DrawShadowText(HDC hdc, LPCWSTR pszText, UINT cch, RECT *prc, DWORD dwFlags,
                           COLORREF crText, COLORREF crShadow, int ixOffset, int iyOffset)
 {
-    FIXME("(%p, %s, %d, %p, %d, 0x%08x, 0x%08x, %d, %d): stub\n", hdc, debugstr_w(pszText), cch, rect, dwFlags,
-                                                                  crText, crShadow, ixOffset, iyOffset);
-    return DrawTextW(hdc, pszText, cch, rect, DT_LEFT);
+    COLORREF crOldText;
+    RECT rcText;
+    INT iRet, x, y, x2, y2;
+    BYTE *pBits;
+    HBITMAP hbm, hbmOld;
+    BITMAPINFO bi;
+    HDC hdcMem;
+    HFONT hOldFont;
+    BLENDFUNCTION bf;
+
+    /* Create 32 bit DIB section for the shadow */
+    ZeroMemory(&bi, sizeof(bi));
+    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
+    bi.bmiHeader.biWidth = prc->right - prc->left + 4;
+    bi.bmiHeader.biHeight = prc->bottom - prc->top + 5; // bottom-up DIB
+    bi.bmiHeader.biPlanes = 1;
+    bi.bmiHeader.biBitCount = 32;
+    bi.bmiHeader.biCompression = BI_RGB;
+    hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, (PVOID*)&pBits, NULL, 0);
+    if(!hbm)
+    {
+        ERR("CreateDIBSection failed\n");
+        return 0;
+    }
+
+    /* Create memory device context for new DIB section and select it */
+    hdcMem = CreateCompatibleDC(hdc);
+    if(!hdcMem)
+    {
+        ERR("CreateCompatibleDC failed\n");
+        DeleteObject(hbm);
+        return 0;
+    }
+
+    hbmOld = (HBITMAP)SelectObject(hdcMem, hbm);
+
+    /* Draw text on our helper bitmap */
+    hOldFont = (HFONT)SelectObject(hdcMem, GetCurrentObject(hdc, OBJ_FONT));
+    SetTextColor(hdcMem, RGB(16, 16, 16));
+    SetBkColor(hdcMem, RGB(0, 0, 0));
+    SetBkMode(hdcMem, TRANSPARENT);
+    SetRect(&rcText, 0, 0, prc->right - prc->left, prc->bottom - prc->top);
+    DrawTextW(hdcMem, pszText, cch, &rcText, dwFlags);
+    SelectObject(hdcMem, hOldFont);
+
+    /* Flush GDI so data pointed by pBits is valid */
+    GdiFlush();
+
+    /* Set alpha of pixels (forget about colors for now. They will be changed in next loop).
+       We copy text image 4*5 times and each time alpha is added */
+    for (x = 0; x < bi.bmiHeader.biWidth; ++x)
+        for (y = 0; y < bi.bmiHeader.biHeight; ++y)
+        {
+            BYTE *pDest = &pBits[(y * bi.bmiHeader.biWidth + x) * 4];
+            UINT Alpha = 0;
+
+            for (x2 = x - 4 + 1; x2 <= x; ++x2)
+                for (y2 = y; y2 < y + 5; ++y2)
+                {
+                    if (x2 >= 0 && x2 < bi.bmiHeader.biWidth && y2 >= 0 && y2 < bi.bmiHeader.biHeight)
+                    {
+                        BYTE *pSrc = &pBits[(y2 * bi.bmiHeader.biWidth + x2) * 4];
+                        Alpha += pSrc[0];
+                    }
+                }
+
+            if (Alpha > 255)
+                Alpha = 255;
+            pDest[3] = Alpha;
+        }
+
+    /* Now set the color of each pixel to shadow color * alpha (see GdiAlphaBlend) */
+    for (x = 0; x < bi.bmiHeader.biWidth; ++x)
+        for (y = 0; y < bi.bmiHeader.biHeight; ++y)
+        {
+            BYTE *pDest = &pBits[(y * bi.bmiHeader.biWidth + x) * 4];
+            pDest[0] = GetBValue(crShadow) * pDest[3] / 255;
+            pDest[1] = GetGValue(crShadow) * pDest[3] / 255;
+            pDest[2] = GetRValue(crShadow) * pDest[3] / 255;
+        }
+
+    /* Fix ixOffset of the shadow (tested on Win) */
+    ixOffset -= 3;
+    iyOffset -= 3;
+
+    /* Alpha blend helper image to destination DC */
+    bf.BlendOp = AC_SRC_OVER;
+    bf.BlendFlags = 0;
+    bf.SourceConstantAlpha = 255;
+    bf.AlphaFormat = AC_SRC_ALPHA;
+    if (!GdiAlphaBlend(hdc, prc->left + ixOffset, prc->top + iyOffset, bi.bmiHeader.biWidth, bi.bmiHeader.biHeight, hdcMem, 0, 0, bi.bmiHeader.biWidth, bi.bmiHeader.biHeight, bf))
+        ERR("GdiAlphaBlend failed: %lu\n", GetLastError());
+
+    /* Delete the helper bitmap */
+    SelectObject(hdcMem, hbmOld);
+    DeleteObject(hbm);
+    DeleteDC(hdcMem);
+
+    /* Finally draw the text over shadow */
+    crOldText = SetTextColor(hdc, crText);
+    SetBkMode(hdc, TRANSPARENT);
+    iRet = DrawTextW(hdc, pszText, cch, prc, dwFlags);
+    SetTextColor(hdc, crOldText);
+
+    return iRet;
 }
 
 /***********************************************************************
Index: propsheet.c
===================================================================
--- propsheet.c	(revision 38890)
+++ propsheet.c	(working copy)
@@ -2425,6 +2425,9 @@
   HWND hwndBack   = GetDlgItem(hwndDlg, IDC_BACK_BUTTON);
   HWND hwndNext   = GetDlgItem(hwndDlg, IDC_NEXT_BUTTON);
   HWND hwndFinish = GetDlgItem(hwndDlg, IDC_FINISH_BUTTON);
+  HWND hwndCancel = GetDlgItem(hwndDlg, IDCANCEL);
+  INT iDefItem = 0;
+  HWND hwndFocus;
 
   TRACE("%d\n", dwFlags);
 
@@ -2432,17 +2435,6 @@
   EnableWindow(hwndNext, FALSE);
   EnableWindow(hwndFinish, FALSE);
 
-  /* set the default pushbutton to an enabled button */
-  if (((dwFlags & PSWIZB_FINISH) || psInfo->hasFinish) && !(dwFlags & PSWIZB_DISABLEDFINISH))
-    SendMessageW(hwndDlg, DM_SETDEFID, IDC_FINISH_BUTTON, 0);
-  else if (dwFlags & PSWIZB_NEXT)
-    SendMessageW(hwndDlg, DM_SETDEFID, IDC_NEXT_BUTTON, 0);
-  else if (dwFlags & PSWIZB_BACK)
-    SendMessageW(hwndDlg, DM_SETDEFID, IDC_BACK_BUTTON, 0);
-  else
-    SendMessageW(hwndDlg, DM_SETDEFID, IDCANCEL, 0);
-
-
   if (dwFlags & PSWIZB_BACK)
     EnableWindow(hwndBack, TRUE);
 
@@ -2472,6 +2464,22 @@
   }
   else if (!(dwFlags & PSWIZB_DISABLEDFINISH))
     EnableWindow(hwndFinish, TRUE);
+
+  /* set the default pushbutton to an enabled button */
+  if (((dwFlags & PSWIZB_FINISH) || psInfo->hasFinish) && !(dwFlags & PSWIZB_DISABLEDFINISH))
+    iDefItem = IDC_FINISH_BUTTON;
+  else if (dwFlags & PSWIZB_NEXT)
+    iDefItem = IDC_NEXT_BUTTON;
+  else if (dwFlags & PSWIZB_BACK)
+    iDefItem = IDC_BACK_BUTTON;
+  else
+    iDefItem = IDCANCEL;
+  SendMessageW(hwndDlg, DM_SETDEFID, iDefItem, 0);
+
+  /* Set focus if no control has it */
+  hwndFocus = GetFocus();
+  if (!hwndFocus || hwndFocus == hwndCancel)
+    SetFocus(GetDlgItem(hwndDlg, iDefItem));
 }
 
 /******************************************************************************
Index: tooltips.c
===================================================================
--- tooltips.c	(revision 38890)
+++ tooltips.c	(working copy)
@@ -2488,8 +2488,33 @@
 static LRESULT
 TOOLTIPS_NotifyFormat (HWND hwnd, WPARAM wParam, LPARAM lParam)
 {
-    FIXME ("hwnd=%p wParam=%lx lParam=%lx\n", hwnd, wParam, lParam);
+    TOOLTIPS_INFO *infoPtr = TOOLTIPS_GetInfoPtr (hwnd);
+    TTTOOL_INFO *toolPtr = infoPtr->tools;
+    INT nResult;
 
+    TRACE("hwnd=%p wParam=%lx lParam=%lx\n", hwnd, wParam, lParam);
+
+    if (lParam == NF_QUERY) {
+        if (toolPtr->bNotifyUnicode) {
+            return NFR_UNICODE;
+        } else {
+            return NFR_ANSI;
+        }
+    }
+    else if (lParam == NF_REQUERY) {
+        nResult = (INT) SendMessageW (toolPtr->hwnd, WM_NOTIFYFORMAT,
+                    (WPARAM)hwnd, (LPARAM)NF_QUERY);
+        if (nResult == NFR_ANSI) {
+            toolPtr->bNotifyUnicode = FALSE;
+            TRACE(" -- WM_NOTIFYFORMAT returns: NFR_ANSI\n");
+        } else if (nResult == NFR_UNICODE) {
+            toolPtr->bNotifyUnicode = TRUE;
+            TRACE(" -- WM_NOTIFYFORMAT returns: NFR_UNICODE\n");
+        } else {
+            TRACE (" -- WM_NOTIFYFORMAT returns: error!\n");
+        }
+        return nResult;
+    }
     return 0;
 }
 
Index: treeview.c
===================================================================
--- treeview.c	(revision 38890)
+++ treeview.c	(working copy)
@@ -2830,7 +2830,12 @@
 	}
     }
 
-    TREEVIEW_UpdateScrollBars(infoPtr);
+    //
+    // This is correct, but is causes and infinite loop of WM_PAINT messages, resulting
+    // in continuous painting of the scroll bar in reactos. Comment out until the real
+    // bug is found
+    // 
+    //TREEVIEW_UpdateScrollBars(infoPtr);
 
     if (infoPtr->cdmode & CDRF_NOTIFYPOSTPAINT)
 	infoPtr->cdmode =
Index: listview.c
===================================================================
--- listview.c	(revision 51320)
+++ listview.c	(working copy)
@@ -315,6 +315,7 @@
   COLORREF clrBk;
   COLORREF clrText;
   COLORREF clrTextBk;
+  BOOL bDefaultBkColor;
 
   /* font */
   HFONT hDefaultFont;
@@ -1699,8 +1700,19 @@
 /* used to handle collapse main item column case */
 static inline BOOL LISTVIEW_DrawFocusRect(const LISTVIEW_INFO *infoPtr, HDC hdc)
 {
-    return (infoPtr->rcFocus.left < infoPtr->rcFocus.right) ?
-            DrawFocusRect(hdc, &infoPtr->rcFocus) : FALSE;
+    BOOL Ret = FALSE;
+
+    if (infoPtr->rcFocus.left < infoPtr->rcFocus.right)
+    {
+        DWORD dwOldBkColor, dwOldTextColor;
+
+        dwOldBkColor = SetBkColor(hdc, RGB(255, 255, 255));
+        dwOldTextColor = SetBkColor(hdc, RGB(0, 0, 0));
+        Ret = DrawFocusRect(hdc, &infoPtr->rcFocus);
+        SetBkColor(hdc, dwOldBkColor);
+        SetBkColor(hdc, dwOldTextColor);
+    }
+    return Ret;
 }
 
 /* Listview invalidation functions: use _only_ these functions to invalidate */
@@ -4698,7 +4710,10 @@
     if (infoPtr->uView == LV_VIEW_DETAILS && infoPtr->dwLvExStyle & LVS_EX_GRIDLINES)
         rcLabel.bottom--;
 
-    DrawTextW(hdc, lvItem.pszText, -1, &rcLabel, uFormat);
+    if ((!(lvItem.state & LVIS_SELECTED) || !infoPtr->bFocus) && (infoPtr->dwLvExStyle & LVS_EX_TRANSPARENTSHADOWTEXT))
+        DrawShadowText(hdc, lvItem.pszText, -1, &rcLabel, uFormat, RGB(255, 255, 255), RGB(0, 0, 0), 2, 2);
+    else
+        DrawTextW(hdc, lvItem.pszText, -1, &rcLabel, uFormat);
 
 postpaint:
     if (cdsubitemmode & CDRF_NOTIFYPOSTPAINT)
@@ -5117,7 +5132,11 @@
 
     /* Draw marquee rectangle if appropriate */
     if (infoPtr->bMarqueeSelect)
+    {
+        SetBkColor(hdc, RGB(255, 255, 255));
+        SetTextColor(hdc, RGB(0, 0, 0));
         DrawFocusRect(hdc, &infoPtr->marqueeDrawRect);
+    }
 
     if (cdmode & CDRF_NOTIFYPOSTPAINT)
 	notify_postpaint(infoPtr, &nmlvcd);
@@ -7927,6 +7946,7 @@
 {
     TRACE("(color=%x)\n", color);
 
+    infoPtr->bDefaultBkColor = FALSE;
     if(infoPtr->clrBk != color) {
 	if (infoPtr->clrBk != CLR_NONE) DeleteObject(infoPtr->hBkBrush);
 	infoPtr->clrBk = color;
@@ -9314,6 +9334,7 @@
   infoPtr->clrText = CLR_DEFAULT;
   infoPtr->clrTextBk = CLR_DEFAULT;
   LISTVIEW_SetBkColor(infoPtr, comctl32_color.clrWindow);
+  infoPtr->bDefaultBkColor = TRUE;
 
   /* set default values */
   infoPtr->nFocusedItem = -1;
@@ -11570,6 +11591,12 @@
 
   case WM_SYSCOLORCHANGE:
     COMCTL32_RefreshSysColors();
+    if (infoPtr->bDefaultBkColor)
+    {
+        LISTVIEW_SetBkColor(infoPtr, comctl32_color.clrWindow);
+        infoPtr->bDefaultBkColor = TRUE;
+        LISTVIEW_InvalidateList(infoPtr);
+    }
     return 0;
 
 /*	case WM_TIMER: */
Index: rebar.c
===================================================================
--- rebar.c	(revision 51320)
+++ rebar.c	(working copy)
@@ -51,7 +51,6 @@
  *   - WM_QUERYNEWPALETTE
  *   - WM_RBUTTONDOWN
  *   - WM_RBUTTONUP
- *   - WM_SYSCOLORCHANGE
  *   - WM_VKEYTOITEM
  *   - WM_WININICHANGE
  *   Notifications:
@@ -2540,10 +2539,8 @@
 
     /* initialize band */
     memset(lpBand, 0, sizeof(*lpBand));
-    lpBand->clrFore = infoPtr->clrText == CLR_NONE ? infoPtr->clrBtnText :
-                                                     infoPtr->clrText;
-    lpBand->clrBack = infoPtr->clrBk == CLR_NONE ? infoPtr->clrBtnFace :
-                                                   infoPtr->clrBk;
+    lpBand->clrFore = infoPtr->clrText;
+    lpBand->clrBack = infoPtr->clrBk;
     lpBand->iImage = -1;
 
     REBAR_CommonSetupBand(infoPtr->hwndSelf, lprbbi, lpBand);
@@ -3793,6 +3790,8 @@
 
         case WM_SYSCOLORCHANGE:
             COMCTL32_RefreshSysColors();
+            infoPtr->clrBtnText = comctl32_color.clrBtnText;
+            infoPtr->clrBtnFace = comctl32_color.clrBtnFace;
             return 0;
 
 /*      case WM_VKEYTOITEM:     supported according to ControlSpy */
Index: monthcal.c
===================================================================
--- monthcal.c	(Revision 51719)
+++ monthcal.c	(Arbeitskopie)
@@ -143,8 +143,8 @@
 /* empty SYSTEMTIME const */
 static const SYSTEMTIME st_null;
 /* valid date limits */
-static const SYSTEMTIME max_allowed_date = { .wYear = 9999, .wMonth = 12, .wDay = 31 };
-static const SYSTEMTIME min_allowed_date = { .wYear = 1752, .wMonth = 9,  .wDay = 14 };
+static const SYSTEMTIME max_allowed_date = { 9999, 12, 0, 31, 0, 0, 0, 0 };
+static const SYSTEMTIME min_allowed_date = { 1752, 9, 0, 14, 0, 0, 0, 0 };

 /* Prev/Next buttons */
 enum nav_direction
