Index: ftp.c
===================================================================
--- ftp.c	(revision 30893)
+++ ftp.c	(working copy)
@@ -58,6 +58,7 @@
 
 #include "wine/debug.h"
 #include "internet.h"
+typedef size_t socklen_t;
 
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
 
Index: http.c
===================================================================
--- http.c	(revision 30893)
+++ http.c	(working copy)
@@ -60,6 +60,8 @@
 #include "wine/debug.h"
 #include "wine/unicode.h"
 
+#include "inet_ntop.c"
+
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
 
 static const WCHAR g_szHttp1_0[] = {' ','H','T','T','P','/','1','.','0',0 };
@@ -3027,14 +3028,21 @@
     /*
      * HACK peek at the buffer
      */
+#if 0
+    /* This is Wine code, we don't support MSG_PEEK yet so we have to do it
+       a bit different */
     NETCON_recv(&lpwhr->netConnection, buffer, buflen, MSG_PEEK, &rc);
+#endif
     /*
      * We should first receive 'HTTP/1.x nnn OK' where nnn is the status code.
      */
     buflen = MAX_REPLY_LEN;
     memset(buffer, 0, MAX_REPLY_LEN);
     if (!NETCON_getNextLine(&lpwhr->netConnection, bufferA, &buflen))
         goto lend;
+#if 1
+    rc = buflen;
+#endif
     MultiByteToWideChar( CP_ACP, 0, bufferA, buflen, buffer, MAX_REPLY_LEN );
 
     /* regenerate raw headers */
Index: inet_ntop.c
===================================================================
--- inet_ntop.c	(revision 30893)
+++ inet_ntop.c	(working copy)
@@ -0,0 +1,189 @@
+/* from	NetBSD: inet_ntop.c,v 1.9 2000/01/22 22:19:16 mycroft Exp */
+
+/* Copyright (c) 1996 by Internet Software Consortium.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS
+ * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE
+ * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
+ * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
+ * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS
+ * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#define ENOSPC 28
+#define EAFNOSUPPORT 52
+
+#ifndef IN6ADDRSZ
+#define	IN6ADDRSZ	16
+#endif
+
+#ifndef INT16SZ
+#define	INT16SZ		2
+#endif
+
+#ifdef SPRINTF_CHAR
+# define SPRINTF(x) strlen(sprintf/**/x)
+#else
+# define SPRINTF(x) ((size_t)sprintf x)
+#endif
+
+/*
+ * WARNING: Don't even consider trying to compile this on a system where
+ * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
+ */
+
+static const char *inet_ntop4(const u_char *src, char *dst, size_t size);
+static const char *inet_ntop6(const u_char *src, char *dst, size_t size);
+
+/* char *
+ * inet_ntop(af, src, dst, size)
+ *	convert a network format address to presentation format.
+ * return:
+ *	pointer to presentation format address (`dst'), or NULL (see errno).
+ * author:
+ *	Paul Vixie, 1996.
+ */
+const char *
+inet_ntop(int af, const void *src, char *dst, size_t size)
+{
+
+	switch (af) {
+	case AF_INET:
+		return (inet_ntop4(src, dst, size));
+#ifdef INET6
+	case AF_INET6:
+		return (inet_ntop6(src, dst, size));
+#endif
+	default:
+		errno = EAFNOSUPPORT;
+		return (NULL);
+	}
+	/* NOTREACHED */
+}
+
+/* const char *
+ * inet_ntop4(src, dst, size)
+ *	format an IPv4 address, more or less like inet_ntoa()
+ * return:
+ *	`dst' (as a const)
+ * notes:
+ *	(1) uses no statics
+ *	(2) takes a u_char* not an in_addr as input
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static const char *
+inet_ntop4(const u_char *src, char *dst, size_t size)
+{
+	static const char fmt[] = "%u.%u.%u.%u";
+	char tmp[sizeof "255.255.255.255"];
+
+	if (SPRINTF((tmp, fmt, src[0], src[1], src[2], src[3])) > size) {
+		errno = ENOSPC;
+		return (NULL);
+	}
+	strcpy(dst, tmp);
+	return (dst);
+}
+
+#ifdef INET6
+/* const char *
+ * inet_ntop6(src, dst, size)
+ *	convert IPv6 binary address into presentation (printable) format
+ * author:
+ *	Paul Vixie, 1996.
+ */
+static const char *
+inet_ntop6(const u_char *src, char *dst, size_t size)
+{
+	/*
+	 * Note that int32_t and int16_t need only be "at least" large enough
+	 * to contain a value of the specified size.  On some systems, like
+	 * Crays, there is no such thing as an integer variable with 16 bits.
+	 * Keep this in mind if you think this function should have been coded
+	 * to use pointer overlays.  All the world's not a VAX.
+	 */
+	char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
+	struct { int base, len; } best, cur;
+	u_int words[IN6ADDRSZ / INT16SZ];
+	int i;
+
+	/*
+	 * Preprocess:
+	 *	Copy the input (bytewise) array into a wordwise array.
+	 *	Find the longest run of 0x00's in src[] for :: shorthanding.
+	 */
+	memset(words, '\0', sizeof words);
+	for (i = 0; i < IN6ADDRSZ; i++)
+		words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
+	best.base = -1;
+	cur.base = -1;
+	for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {
+		if (words[i] == 0) {
+			if (cur.base == -1)
+				cur.base = i, cur.len = 1;
+			else
+				cur.len++;
+		} else {
+			if (cur.base != -1) {
+				if (best.base == -1 || cur.len > best.len)
+					best = cur;
+				cur.base = -1;
+			}
+		}
+	}
+	if (cur.base != -1) {
+		if (best.base == -1 || cur.len > best.len)
+			best = cur;
+	}
+	if (best.base != -1 && best.len < 2)
+		best.base = -1;
+
+	/*
+	 * Format the result.
+	 */
+	tp = tmp;
+	for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++) {
+		/* Are we inside the best run of 0x00's? */
+		if (best.base != -1 && i >= best.base &&
+		    i < (best.base + best.len)) {
+			if (i == best.base)
+				*tp++ = ':';
+			continue;
+		}
+		/* Are we following an initial run of 0x00s or any real hex? */
+		if (i != 0)
+			*tp++ = ':';
+		/* Is this address an encapsulated IPv4? */
+		if (i == 6 && best.base == 0 &&
+		    (best.len == 6 || (best.len == 5 && words[5] == 0xffff))) {
+			if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
+				return (NULL);
+			tp += strlen(tp);
+			break;
+		}
+		tp += SPRINTF((tp, "%x", words[i]));
+	}
+	/* Was it a trailing run of 0x00's? */
+	if (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ))
+		*tp++ = ':';
+	*tp++ = '\0';
+
+	/*
+	 * Check for overflow, copy, and we're done.
+	 */
+	if ((size_t)(tp - tmp) > size) {
+		errno = ENOSPC;
+		return (NULL);
+	}
+	strcpy(dst, tmp);
+	return (dst);
+}
+#endif
+
Index: internet.c
===================================================================
--- internet.c	(revision 30893)
+++ internet.c	(working copy)
@@ -67,6 +67,7 @@
 #include "resource.h"
 
 #include "wine/unicode.h"
+#define CP_UNIXCP CP_THREAD_ACP
 
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
 
Index: netconnection.c
===================================================================
--- netconnection.c	(revision 30893)
+++ netconnection.c	(working copy)
@@ -58,6 +58,8 @@
 #include "internet.h"
 
 #define RESPONSE_TIMEOUT        30            /* FROM internet.c */
+#define sock_get_error(x) WSAGetLastError()
+#undef FIONREAD
 
 
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
@@ -200,6 +202,7 @@
         return TRUE;
 }
 
+#ifndef __REACTOS__
 /* translate a unix error code into a winsock one */
 static int sock_get_error( int err )
 {
@@ -263,6 +266,7 @@
     default: errno=err; perror("sock_set_error"); return WSAEFAULT;
     }
 }
+#endif
 
 /******************************************************************************
  * NETCON_create
Index: rsrc.rc
===================================================================
--- rsrc.rc	(revision 30893)
+++ rsrc.rc	(working copy)
@@ -60,3 +60,4 @@
 #include "wininet_Si.rc"
 #include "wininet_Sv.rc"
 #include "wininet_Tr.rc"
+#include "wininet_Uk.rc"
Index: utility.c
===================================================================
--- utility.c	(revision 30893)
+++ utility.c	(working copy)
@@ -37,6 +37,7 @@
 
 #include "wine/debug.h"
 #include "internet.h"
+#define CP_UNIXCP CP_THREAD_ACP
 
 WINE_DEFAULT_DEBUG_CHANNEL(wininet);
 
Index: wininet.rbuild
===================================================================
--- wininet.rbuild	(revision 30893)
+++ wininet.rbuild	(working copy)
@@ -18,6 +18,7 @@
 	<library>ntdll</library>
 	<library>secur32</library>
 	<library>crypt32</library>
+	<library>ws2_32</library>
 	<file>cookie.c</file>
 	<file>dialogs.c</file>
 	<file>ftp.c</file>
Index: wininet_Uk.rc
===================================================================
--- wininet_Uk.rc	(revision 30893)
+++ wininet_Uk.rc	(working copy)
@@ -0,0 +1,46 @@
+/*
+ * wininet.dll (Ukrainian resources)
+ *
+ * Copyright 2006 Artem Reznikov
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+LANGUAGE LANG_UKRAINIAN, SUBLANG_DEFAULT
+
+IDD_PROXYDLG DIALOG LOADONCALL MOVEABLE DISCARDABLE 36, 24, 250, 154
+STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
+CAPTION "Введіть Мережний Пароль"
+FONT 8, "MS Shell Dlg"
+{
+ LTEXT "Будь ласка, введіть Ваші ім'я та пароль:", -1, 40, 6, 150, 15
+ LTEXT "Проксі", -1, 40, 26, 50, 10
+ LTEXT "Область", -1, 40, 46, 50, 10
+ LTEXT "Користувач", -1, 40, 66, 50, 10
+ LTEXT "Пароль", -1, 40, 86, 50, 10
+ LTEXT "" IDC_PROXY, 80, 26, 150, 14, 0
+ LTEXT "" IDC_REALM, 80, 46, 150, 14, 0
+ EDITTEXT IDC_USERNAME, 80, 66, 150, 14, ES_AUTOHSCROLL | WS_BORDER | WS_TABSTOP
+ EDITTEXT IDC_PASSWORD, 80, 86, 150, 14, ES_AUTOHSCROLL | WS_BORDER | WS_TABSTOP | ES_PASSWORD
+ CHECKBOX "&Зберегти цей пароль (небезпечно)", IDC_SAVEPASSWORD,
+           80, 106, 150, 12, BS_AUTOCHECKBOX | WS_GROUP | WS_TABSTOP
+ PUSHBUTTON "OK", IDOK, 98, 126, 56, 14, WS_GROUP | WS_TABSTOP | BS_DEFPUSHBUTTON
+ PUSHBUTTON "Скасувати", IDCANCEL, 158, 126, 56, 14, WS_GROUP | WS_TABSTOP
+}
+
+STRINGTABLE DISCARDABLE
+{
+  IDS_LANCONNECTION "Підключення по локальній мережі"
+}
