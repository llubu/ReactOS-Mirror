#include <ddk/ntddk.h>
#include <win32k/dc.h>
#include "../../drivers/input/include/mouse.h"
#include "objects.h"

static BOOLEAN SafetySwitch = FALSE;
static BOOLEAN SafetySwitch2 = FALSE;
static BOOLEAN MouseEnabled = FALSE;
static LONG mouse_x, mouse_y;
static UINT mouse_width = 0, mouse_height = 0;
static UCHAR DefaultCursor[256] = {
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0x00, 0x00, 
  0x00, 0xC0, 0x00, 0x00, 
  0x01, 0x80, 0x00, 0x00, 
  0x01, 0x80, 0x00, 0x00, 
  0x03, 0x00, 0x00, 0x00, 
  0x43, 0x00, 0x00, 0x00, 
  0x66, 0x00, 0x00, 0x00, 
  0x76, 0x00, 0x00, 0x00, 
  0x7E, 0x00, 0x00, 0x00, 
  0x7F, 0xC0, 0x00, 0x00, 
  0x7F, 0x80, 0x00, 0x00, 
  0x7F, 0x00, 0x00, 0x00, 
  0x7E, 0x00, 0x00, 0x00, 
  0x7C, 0x00, 0x00, 0x00, 
  0x78, 0x00, 0x00, 0x00, 
  0x70, 0x00, 0x00, 0x00, 
  0x60, 0x00, 0x00, 0x00, 
  0x40, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 

  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0xFF, 0xFF, 0xFF, 
  0xFF, 0x3F, 0xFF, 0xFF, 
  0xFE, 0x1F, 0xFF, 0xFF, 
  0xFE, 0x1F, 0xFF, 0xFF, 
  0xFC, 0x3F, 0xFF, 0xFF, 
  0x7C, 0x3F, 0xFF, 0xFF, 
  0x38, 0x7F, 0xFF, 0xFF, 
  0x18, 0x7F, 0xFF, 0xFF, 
  0x00, 0xFF, 0xFF, 0xFF, 
  0x00, 0xFF, 0xFF, 0xFF, 
  0x00, 0x0F, 0xFF, 0xFF, 
  0x00, 0x1F, 0xFF, 0xFF, 
  0x00, 0x3F, 0xFF, 0xFF, 
  0x00, 0x7F, 0xFF, 0xFF, 
  0x00, 0xFF, 0xFF, 0xFF, 
  0x01, 0xFF, 0xFF, 0xFF, 
  0x03, 0xFF, 0xFF, 0xFF, 
  0x07, 0xFF, 0xFF, 0xFF, 
  0x0F, 0xFF, 0xFF, 0xFF, 
  0x1F, 0xFF, 0xFF, 0xFF, 
  0x3F, 0xFF, 0xFF, 0xFF};

INT MouseSafetyOnDrawStart(PSURFOBJ SurfObj, PSURFGDI SurfGDI, LONG HazardX1, LONG HazardY1, LONG HazardX2, LONG HazardY2)
{
  RECTL MouseRect;
  LONG tmp;

  if(SurfObj == NULL) return 0;

  if((SurfObj->iType != STYPE_DEVICE) || (MouseEnabled == FALSE)) return 0;

  if(HazardX1 > HazardX2) { tmp = HazardX2; HazardX2 = HazardX1; HazardX1 = tmp; }
  if(HazardY1 > HazardY2) { tmp = HazardY2; HazardY2 = HazardY1; HazardY1 = tmp; }

  if( (mouse_x + mouse_width >= HazardX1)  && (mouse_x <= HazardX2) &&
      (mouse_y + mouse_height >= HazardY1) && (mouse_y <= HazardY2) )
  {
    SurfGDI->MovePointer(SurfObj, -1, -1, &MouseRect);
    SafetySwitch = TRUE;
  }

  // Mouse is not allowed to move if GDI is busy drawing
  SafetySwitch2 = TRUE;

  return 1;
}

INT MouseSafetyOnDrawEnd(PSURFOBJ SurfObj, PSURFGDI SurfGDI)
{
  RECTL MouseRect;

  if(SurfObj == NULL) return 0;

  if((SurfObj->iType != STYPE_DEVICE) || (MouseEnabled == FALSE)) return 0;

  if(SafetySwitch == TRUE)
  {
    SurfGDI->MovePointer(SurfObj, mouse_x, mouse_y, &MouseRect);
    SafetySwitch = FALSE;
  }

  SafetySwitch2 = FALSE;

  return 1;
}

VOID MouseGDICallBack(PMOUSE_INPUT_DATA Data, ULONG InputCount)
{
  ULONG i;
  LONG mouse_cx = 0, mouse_cy = 0;
  HDC hDC = W32kGetScreenDC();
  PDC dc;
  PSURFOBJ SurfObj;
  PSURFGDI SurfGDI;
  RECTL MouseRect; 

  PDEVICE_OBJECT ClassDeviceObject = NULL;
  PFILE_OBJECT FileObject = NULL;
  NTSTATUS status;
  UNICODE_STRING ClassName;
  IO_STATUS_BLOCK ioStatus;
  KEVENT event;
  PIRP irp;

  if (hDC == 0)
    {
      return;
    }

  dc = DC_HandleToPtr(hDC);
  SurfObj = (PSURFOBJ)AccessUserObject(dc->Surface);
  SurfGDI = (PSURFGDI)AccessInternalObject(dc->Surface);

  // Compile the total mouse movement change
  for (i=0; i<InputCount; i++)
  {
    mouse_cx += Data[i].LastX;
    mouse_cy += Data[i].LastY;
  }

  if((mouse_cx != 0) || (mouse_cy != 0))
  {
    mouse_x += mouse_cx;
    mouse_y += mouse_cy;

    if(mouse_x < 0) mouse_x = 0;
    if(mouse_y < 0) mouse_y = 0;
    if(mouse_x > 620) mouse_x = 620;
    if(mouse_y > 460) mouse_y = 460;

    if((SafetySwitch == FALSE) && (SafetySwitch2 == FALSE)) ;
    SurfGDI->MovePointer(SurfObj, mouse_x, mouse_y, &MouseRect); 
  }
}

VOID EnableMouse(HDC hDisplayDC)
{
  PDC dc = DC_HandleToPtr(hDisplayDC);
  PSURFOBJ SurfObj = (PSURFOBJ)AccessUserObject(dc->Surface);
  PSURFGDI SurfGDI = (PSURFGDI)AccessInternalObject(dc->Surface);
  BOOL txt;
  int i;

  BRUSHOBJ Brush;
  HBITMAP hMouseSurf;
  PSURFOBJ MouseSurf;
  SIZEL MouseSize;
  POINTL ZeroPoint;
  RECTL MouseRect;

  /* Create the default mouse cursor. */
  mouse_width = 32;
  mouse_height = 32;
  MouseSize.cx = 32;
  MouseSize.cy = 64;
  hMouseSurf = EngCreateBitmap(MouseSize, 4, BMF_1BPP, 0, DefaultCursor);
  MouseSurf = (PSURFOBJ)AccessUserObject(hMouseSurf);

  /* Tell the display driver to set the pointer shape. */
  SurfGDI->SetPointerShape(SurfObj, MouseSurf, NULL, NULL, 0, 0, 320, 240, 
			   &MouseRect, 0);

  mouse_x = 320;
  mouse_y = 240;
  MouseEnabled = TRUE;
}

